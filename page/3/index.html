<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="java 学习 Spring Cloud 微服务 图解源码 陈功">
<meta property="og:type" content="website">
<meta property="og:title" content="CGの笔记向开发万事屋">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="CGの笔记向开发万事屋">
<meta property="og:description" content="java 学习 Spring Cloud 微服务 图解源码 陈功">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CGの笔记向开发万事屋">
<meta name="twitter:description" content="java 学习 Spring Cloud 微服务 图解源码 陈功">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>CGの笔记向开发万事屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CGの笔记向开发万事屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">欢迎来到黑铁酒吧，哦不，CG的万事屋(●'◡'●)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/04/06-大后端-05架构-02微服务-01Spring-Cloud-09-Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/06-大后端-05架构-02微服务-01Spring-Cloud-09-Stream/" itemprop="url">02微服务-01Spring-Cloud-09-bus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-04T14:42:16Z">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基于rabbit和kafka。一个是stream作为服务之间的通信MQ，一个是bus主要用来关于广播配置的。</p>
<p>Bus是一个轻量级的消息代理，不同于stream作为服务与服务间的通信。Bus让<strong>所有服务</strong>连接上来，该主题的消息会被所有实例监听消费，所以我们叫他消息总线。<br><strong>消息总线</strong>上的各个实例可以方便地广播一些需要让其他连接都知道得消息，比如配置信息或者一些操作管理，通常用来广播配置，实现动态刷新配置。</p>
<h1 id="RabbitMQ实现消息总线"><a href="#RabbitMQ实现消息总线" class="headerlink" title="RabbitMQ实现消息总线"></a>RabbitMQ实现消息总线</h1><h1 id="一、整合spring-cloud-bus动态刷新配置"><a href="#一、整合spring-cloud-bus动态刷新配置" class="headerlink" title="一、整合spring cloud bus动态刷新配置"></a>一、整合spring cloud bus动态刷新配置</h1><p>1）准备：config-repo、config-server-eureka启动他们<br>2）改造config-client-eureka，为其增加amqp</p>
<p><em>pom增加amqp和actuator（提供刷新端点）；
</em>配置中增加RabbitMQ的连接和用户信息</p>
<pre><code>spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=cg
spring.rabbitmq.password=123456
</code></pre><p>3)启动两个config-client-eureka，在不同的port上<br>4）试验：我们先访问config-client-eureka /from请求，可以看到获取到了配置信息<br>然后我们修改repo的配置，然后post请求/bus/refresh到onfig-client-eureka.<br>然后我们再访问两个客户端的/from ，将会看到修改后的配置文件</p>
<img src="/2018/05/04/06-大后端-05架构-02微服务-01Spring-Cloud-09-Stream/3.jpg" title="架构图">
<p>系统启动后，三个Service-A都会连接到Config-Server去获取配置。<br>如果我们修改Service-A的属性，我们需要向其中一个比如3实例发送/bus/refresh 的post请求。该请求会刷新到消息总线中，实例1，2也会获取到，从而实现动态更新。<br>局部刷新同样我们可以实现，通过/bus/refresh?destination=customers:9000，来指定刷新某个服务的配置</p>
<img src="/2018/05/04/06-大后端-05架构-02微服务-01Spring-Cloud-09-Stream/4.jpg" title="架构优化">
<p>上面的架构，服务配置更新需要指向某个实例，web hook配置写死了，如果以后进行服务器迁移，还不得不修改web hook的配置，所以需要调整。<br>在ConfigServer中引入SpringCloudBus，将其引入到消息总线中。 /bus/refresh请求直接post给ConfigServer就可以了。并通过/bus/refresh?destination=customers:9000的形式来指定更新配置</p>
<h2 id="kafaka-spring-cloud-bus"><a href="#kafaka-spring-cloud-bus" class="headerlink" title="kafaka + spring cloud bus"></a>kafaka + spring cloud bus</h2><p><em>pom需要引入spring-cloud-starter-bus-kafka
</em>吧刚才的zookeeper+kafka启动起来，之前amqp整合中将破灭修改后，直接启动config-server和config-client</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/03/10-Linux-01-Cent-7最小化安装及网络配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/10-Linux-01-Cent-7最小化安装及网络配置/" itemprop="url">10-Linux-01-Cent 7最小化安装及网络配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T14:17:18Z">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/10-linux-01-Cent-7最小化安装及网络配置/" itemprop="url" rel="index">
                    <span itemprop="name">-10.linux-01.Cent 7最小化安装及网络配置</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Disk-Partition"><a href="#Disk-Partition" class="headerlink" title="Disk Partition"></a>Disk Partition</h1><p><em>磁盘分区，磁盘存储数据，就像哈希表储存数据，数据储存在不同的区域，存在一个一个散列的区块上。（windows上的磁盘整理就是吧散列的数据整理到一块，很像jvm处理内存区域的样子…( ＿ ＿)ノ｜）
</em>硬盘的分区，可以为不同的分区制定不同的文件格式，而linux和windows所需要的磁盘格式不一致。<br><em>LINUX核心组成：hardware manage；memory manage；i/o；vfs；process manage
</em>linux版本号：{relase version}.{偶数稳定/奇数开发板}.{错误修补次数}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/06-大后端-05架构-02微服务-01Spring-Cloud-08-Bus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/20/06-大后端-05架构-02微服务-01Spring-Cloud-08-Bus/" itemprop="url">02微服务-01Spring-Cloud-08-Stream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-20T15:14:33Z">
                2018-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>消息队列</strong>，应用在spring cloud之中大概有两个。<br>一个是stream作为服务之间的通信MQ，一个是bus是关于广播配置的，都基于rabbit和kafka。<br>那么什么是消息队列，为什么需要消息队列？</p>
<p>简单的来说，打个比方，一个话多的女朋友给一个木讷的男朋友发信息。<br>女生发送信息非常快，巴拉巴拉的发，而男生不懂女生的心思，十多分钟才能弄明白女生的一条信息。<br>如果没有收件箱，要等男的看完一个，消息却不停涌入，男生会崩溃。<br>可以把我们的消息队列当作收件箱，男生处理完一条信息，再去都下一条信息。</p>
<h1 id="举几个消息队列的应用实例"><a href="#举几个消息队列的应用实例" class="headerlink" title="举几个消息队列的应用实例"></a>举几个消息队列的应用实例</h1><p>就是用来解耦，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，作为一个中间件的存在，接收和分发消息。应用场景举个例子如下</p>
<blockquote>
<p>假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：</p>
</blockquote>
<ol>
<li>校验用户名等信息，如果没问题会在数据库中添加一个用户记录</li>
<li>如果是用邮箱注册会给你发送一封注册成功的邮件，</li>
<li>手机注册则会发送一条短信分析用户的个人信息，以便将来向他推荐一些志同道合的人，</li>
<li>或向那些人推荐他发送给用户一个包含操作指南的系统通知等等……</li>
</ol>
<p>但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。</p>
<p>实际上很多地方需要：</p>
<ul>
<li>上述的异步处理，提升系统响应性能</li>
<li>应用解耦，接收者可以随意增加，不影响发布者，消息发送成功不影响消息接收者</li>
<li>最终一致性：先写消息再操作，操作完成后再修改状态（订单系统与库存系统的一致性）</li>
<li>广播：只需要关心是否发送到消息队列，下游怎么接受是下游的事情</li>
<li>流量削峰：上下游处理能力有差距时，承担一个缓冲地带的功能。（秒杀抢购，请求先存放在消息队列，等待服务器处理）</li>
<li>日志：利用kafaka，解决大量日志传输；（获取用户id，浏览器，ip等信息，通过flume日志收集器进行收集，传到MQ之中——进行流计算并可视化呈现，或者是进行归档，离线计算 处理后存到mysql）</li>
<li>通信：可以单纯作为点对点队列或者聊天室</li>
</ul>
<p>我们之前讲到，SpringCloudConfig通过refresh执行，刷新客户端配置，微服务的客户端越来越多的时候，每个客户端都需要执行一下refresh，这样是不是很不合适，我们现需要消息代理，构建一个公用的消息主题让所有微服务连接上来，该主题的消息会被所有实例监听和消费，所以称为消息总线。</p>
<p>讲到这，<strong>消息队列</strong>和<strong>消息总线</strong>有什么区别？</p>
<blockquote>
<p>消息总线是基于一个已经相当成熟的消息队列或者消息系统做二次封装</p>
</blockquote>
<ol>
<li>消息队列clientAPI权限太大，clientAPI信任级别太高</li>
<li>消息队列clientAPI面向技术，消息总线clientAPI面向技术+业务</li>
<li>消息队列无法隐藏通信细节</li>
<li>消息队列无法实施实时管控</li>
<li>总线的优势：统一入口，简化拦截成本</li>
</ol>
<p>各种消息队列：ActiveMQ、RabbitMQ、Kafka、RocketMQ<br>spring cloud bus 支持RabbitMQ、Kafka。</p>
<h1 id="RabbitMQ实现"><a href="#RabbitMQ实现" class="headerlink" title="RabbitMQ实现"></a>RabbitMQ实现</h1><p>AMQP（高级 消息 队列 协议）的实现，面向消息的中间件，性能高，由Erlang编写</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>Broker：消息队列服务器实体，接受消息发送者的笑意，然后发送给接收者或者其他Broker</li>
<li>Exchange：消息交换机，消息第一个到达地方，消息通过他指定的路由规则进行分发</li>
<li>Queue：消息发送通过路由后最终到达地，进去队列等待消费</li>
<li>Binding：将Exchange和Queue按路由规则绑定起来</li>
<li>Channal：消息通道，用于连接发送接受消息的逻辑结构，每个Channal代表一个会话任务</li>
</ul>
<p>消息队列过程：</p>
<ol>
<li>客户端连接到消息队列服务器，打开一个Channal</li>
<li>客户端声明Exchange</li>
<li>客户端声明Queue</li>
<li>客户端Binding Exchange和Queue</li>
<li>发送消息</li>
<li>Exchange根据Binding进行消息路由，将消息投递到一个或多个Queue。echange有几种类型：Direct、topic、fanout</li>
</ol>
<p>RabbitMQ支持消息持久化，包括Exchange持久化、Queue持久化、消息持久化</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><p><em>首先我们需要下载RabbitMQ和Erlang，然后安装他们。
</em>rabbitmq自带管理后台，安装后需要配置开启</p>
<pre><code>rabbitmq-plugins enable rabbitmq_management
</code></pre><p>*重启rabbitmq服务</p>
<pre><code>rabbitmq-server stop
rabbitmq-server start
</code></pre><p><em>进入管理页面 <a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a>  guest guest
</em>进入Admin选项卡，创建一个springcloud用户，tags是Rabbit角色分类，给管理员角色<br><em>virtual hosts管理，相当于数据库，可以通过右侧virtual host进入进行添加，以/ 开头，可以进行用户授权<br>进入管理界面，可以进行set permission操作
</em>Web 控制台会展示很多 RabbitMQ 信息，但最最重要的就一个：Unacked Message。这个数据会直接显示在登录之后的 Overview 标签中，第一眼就能看到。Unacked Message 指的是还没有被处理的消息。正常情况下，这个值应该为 0。如果这个值不是 0，并且持续增长，那你就得注意了，这意味着 RabbitMQ 出现了问题，队列开始积压，消息开始堆积，是一个严重的信号.</p>
<h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><p>Spring Boot整合RabbitMQ，实现一个最小化的发送接受消息的例子。<br>1) 新建rabbitmq-hello工程，pom引入spring-boot-starter-amqp<br>2）三个类Config、send、reciever</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver  : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>3）配置</p>
<pre><code>spring.application.name=spirng-boot-rabbitmq
spring.rabbitmq.host=localhost
#连接rabbit的端口为5672.15672是管理页面的端口
spring.rabbitmq.port=5672
spring.rabbitmq.username=springcloud
spring.rabbitmq.password=***
</code></pre><p>4）启动主类，连接上<br><img src="/2018/04/20/06-大后端-05架构-02微服务-01Spring-Cloud-08-Bus/1.jpg" title="Connections"><br><img src="/2018/04/20/06-大后端-05架构-02微服务-01Spring-Cloud-08-Bus/2.jpg" title="Channels"></p>
<p>5)编写测试类</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqHelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>运行测试类，可看到发送和接受消息</p>
<h2 id="原生实现实例"><a href="#原生实现实例" class="headerlink" title="原生实现实例"></a>原生实现实例</h2><h3 id="1、rabbit6大之simple-queues"><a href="#1、rabbit6大之simple-queues" class="headerlink" title="1、rabbit6大之simple queues"></a>1、rabbit6大之simple queues</h3><p><strong>以下均在amqp项目中测试</strong><br>P ———— queue ———— C<br>我们用java来实现一个简单队列，有一个发送消息和一个消费消息的，来发送一个hello world<br>1）建立一个maven项目，引入依赖 rabbitmq client<br>2）获取Mq连接工具类</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getCon</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//建立连接工厂及连接属性（继承项目会做配置的，这里直接写在代码里）</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/vh"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"springcloud"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">//获取连接--创建channel</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>3）Provider<br>这里做一个循环发送消息的测试，运行send，可以看到消息队列运行的情况；同时可以进入Queues页签，点击Get Messages，可以获取message信息</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Utils.ConnectionUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        String message = <span class="string">"Hello CG!"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"&#123;&#125;'"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>4）Consumer</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列，第二个参数是autoack自动应答，返回一个到达的信息，表示已经消费掉了消息，如果不加</span></span><br><span class="line">        <span class="comment">//消息会继续存在再消息队列中造成积压</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="2、rabbit6大之Work-queues"><a href="#2、rabbit6大之Work-queues" class="headerlink" title="2、rabbit6大之Work queues"></a>2、rabbit6大之Work queues</h3><p>P ———— queue ————|——— C1<br>P ———— queue ————|——— C2<br>P ———— queue ————|——— C3<br>P ———— queue ————|——— C4</p>
<p>上面的只有一个消费者，且消费者生产者耦合再一起，多个消费者无法消费，如果队列名变更了，是不是P/C都要变更<br>1)工作队列-轮询分发<br>接上面一个，我们来一个发送者，两个接收者，一个接收者线程100ms中断一个200ms中断，看看消费情况</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            String message = <span class="string">"Hello CG!"</span>;</span><br><span class="line">            message+=i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"&#123;&#125;'"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>可以看到消费端被均匀分发，无论消费端的处理能力，消息被均分了</p>
<p>2)工作队列-公平分发<br>rabbit将发送一条给消费者，等待消费者处理应答，处理完成再发下一条，按照处理能力发送了<br>使用此模式，acsk自动应答必须改为手动</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//告知队列,每次只发一条，消费者处理确认前不再发送</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            String message = <span class="string">"Hello CG!"</span>;</span><br><span class="line">            message+=i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"&#123;&#125;'"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列,关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//一旦又消息进入队列，就会触发消费者handleDelivery方法</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"consumer2"</span>+msg);</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列,关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>可以看到控制台打印的信息，两个消费者不再平均分配任务了</p>
<p>3)自动应答与持久化<br>上面的自动应答设置可以改写如下，清晰点。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> autoAsk=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//监听队列,关闭自动应答</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME,autoAsk,consumer);</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>（自动应答true，自动确认模式）自动应答的含义：消息投递到消费者后，消息从内存中删掉。（这种情况下可能会丢失处理中的消息！消息队列发出消息后，删除消息，但是消费者处理时发生崩溃，消息丢失）</li>
<li>（自动应答false，手动模式）一个消费者挂了，超时未收到回执，则将消息发送给另一个消费者，消费者处理完毕后，发送成功回执，消息队列删除消息。但是加入我们消息队列服务器挂了，我们的消息仍然丢失，这时候我们需要消息持久化</li>
</ul>
<p>rabbitMQ消息持久化：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否持久化</span></span><br><span class="line"><span class="keyword">boolean</span> duravle=<span class="keyword">false</span>;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, duravle, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</code></pre><p>将程序中的false改为true，无法生效还会报错，因为消息队列channel只能声明一次，已经定义好了，（可以从控制台删了再次声明，或者新建一个channel）</p>
<h3 id="3、rabbit6大之Publish-Subscribe"><a href="#3、rabbit6大之Publish-Subscribe" class="headerlink" title="3、rabbit6大之Publish/Subscribe"></a>3、rabbit6大之Publish/Subscribe</h3><p>之前的都是被一个消费者消费，发送一条，被消费者争抢。<br>现在我们需要多个消费者，发送一条消息，让所有消费者都能消费。可以采用订阅模式</p>
<ul>
<li>work队列：一个队列对应多个消费者<br>P ———— queue ——— | ——— C1<br>P ———— queue ——— | ——— C2<br>P ———— queue ——— | ——— C3<br>P ———— queue ——— | ——— C4</li>
<li><p>订阅模式：引入交换机，需要将队列绑定到交换机。一个交换机对应多个队列，一个队列对应一个消费者<br>P ——x—— |—queue1 ——— |— C1<br>P ——x—— |—queue2 ——— |— C2<br>P ——x—— |—queue3 ——— |— C3<br>P ——x—— |—queue4 ——— |— C4<br>应用场景：注册完成—发送邮件与短信；或者修改商品—更改搜索引擎，同时修改库存，前台信息</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel=ConnectionUtils.getChan();</span><br><span class="line">        <span class="comment">//设置分发类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg=<span class="string">"hello ps"</span>;</span><br><span class="line">        <span class="comment">//发送到exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过以上代码，我们可以进入控制台exhcange页签，看到test_exchange，但是消息已经丢失了。<br>因为rabbitMQ只有队列又存储能力，而没有队列绑定到exchange，所以数据丢失了。<br>我们需要添加消费者，通过队列绑定exchange，接受消息</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_fanout_email"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = ConnectionUtils.getChan();</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//绑定到exhcnage</span></span><br><span class="line">    channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//监听队列</span></span><br><span class="line">    channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_fanout_sms"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = ConnectionUtils.getChan();</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//绑定到exhcnage</span></span><br><span class="line">    channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//消费消息</span></span><br><span class="line">    DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//监听队列</span></span><br><span class="line">    channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>运行程序，可以看到均受到了消息。</p>
<h3 id="4、rabbit6大之Routing"><a href="#4、rabbit6大之Routing" class="headerlink" title="4、rabbit6大之Routing"></a>4、rabbit6大之Routing</h3><p>消息增加一个key，只把消息转到相应key的队列。如下，key=”error”,会路由到所有队列；key=”info”，只路由到queue2<br>p—x(type=direct)—|—error—|—-queue1 —- c1<br>p—x(type=direct)—|–info —-|↘<br>p—x(type=direct)—|–error —|→ –queue2— c2<br>p—x(type=direct)—|–warning–|↗</p>
<p><strong>exchange：</strong><br>1.匿名转发(之前演示的)</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机 fanout不处理路由键，只需要将队列绑定到交换机，和exchange绑定的队列均能收到消息</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br></pre></td></tr></table></figure>
</code></pre><p>2.处理路由键</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机 处理路由键 Direct，消息增加一个key，只把消息转到相应key的队列</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_direct"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        <span class="comment">//设置分发类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"direct"</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg=<span class="string">"hello direct"</span>;</span><br><span class="line">        String routingKey=<span class="string">"error"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        channel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_direct_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绑定到exhcnage,并设置routingKey</span></span><br><span class="line">        String routingKey=<span class="string">"error"</span>;</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,routingKey);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="5、rabbit6大之Topics"><a href="#5、rabbit6大之Topics" class="headerlink" title="5、rabbit6大之Topics"></a>5、rabbit6大之Topics</h3><p>Topics:将路由和某个模式匹配，用符号来表示 #匹配一个或多个；*匹配一个</p>
<p>p—x(type=topic)— |—<em>.orange.</em>—|—-queue1 —- c1<br>p—x(type=topic)— |–<em>.</em>.rabbit —-|↘<br>p—x(type=topic)— |–lazy.# —|→ –queue2— c2<br>p—x(type=topic)— |–warning–|↗</p>
<img src="/2018/04/20/06-大后端-05架构-02微服务-01Spring-Cloud-08-Bus/5.jpg" title="topic模式示意图">
<p>生产者发布 删除 修改 查询 商品<br>c1 只收某一个发布<br>c2 收所有发布</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sendmess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">sendmess</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        <span class="comment">//设置分发类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg=<span class="string">"添加 iphone x"</span>;</span><br><span class="line">        String routingKey=<span class="string">"goods.add"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"发送了"</span>+msg);</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_topic_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绑定到exhcnage,并设置routingKey</span></span><br><span class="line">        <span class="comment">//消费者1只能拿添加的消息</span></span><br><span class="line">        String routingKey=<span class="string">"goods.add"</span>;</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,routingKey);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_queue_topic_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//绑定到exhcnage,并设置routingKey</span></span><br><span class="line">        <span class="comment">//消费者2拿所有商品操作消息</span></span><br><span class="line">        String routingKey=<span class="string">"goods.#"</span>;</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,routingKey);</span><br><span class="line">        <span class="comment">//消费消息</span></span><br><span class="line">        DefaultConsumer consumer=<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="6、rabbit6大之Rpc"><a href="#6、rabbit6大之Rpc" class="headerlink" title="6、rabbit6大之Rpc"></a>6、rabbit6大之Rpc</h3><p>之前几个例子都是再本地执行。RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。<br>其实RPC的方式就是springcloud使用rabbit的方式，前面SpringCloudConfig接受git flow的refresh消息实现动态刷新即是一个示例，不过我们用的封装号的AmqpTemplate实现而已.</p>
<h3 id="rabbitMQ消息确认机制"><a href="#rabbitMQ消息确认机制" class="headerlink" title="rabbitMQ消息确认机制"></a>rabbitMQ消息确认机制</h3><p>rabbitMQ可以通过持久化解决服务器异常造成的数据丢失问题。而生产者发送消息后，消息到底有没有到达服务器，默认情况是不知道的。要知道消息到达服务器一般有如下两种方式</p>
<p><em>AMQP实现了事务机制
</em>Confirm模式</p>
<p>1）AMQP实现了事务机制（类似于数据库）</p>
<pre><code>*txSelect    用户将当前channel设置成transation模式
*txCommit    提交
*rxRollback  回滚
</code></pre><p>示例代码</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxSend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_tx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        String msg=<span class="string">"hello tx message"</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            channel.txSelect();</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            <span class="comment">//模拟抛出异常</span></span><br><span class="line">            <span class="keyword">int</span> x=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            channel.txCommit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            channel.txRollback();</span><br><span class="line">            System.out.println(<span class="string">"fail to send! rollback"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_tx"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>2）Confirm模式<br>上面的事务模式发送消息，去的消息的消息确认机制。走协议路径，其实大大降低了消息吞吐量！<br>confirm模式则不会。<br>实现原理</p>
<pre><code>生产者将channel设置未comfirm模式，所有的消息都有唯一的id，一旦消息投递到所有匹配到队列后，rabbit会回执一条消息，使得生产者知道消息发送成功
</code></pre><p>comfirm模式最大的优势就是异步处理！不像AMQP走串行模式</p>
<p>编程模式：<br>*普通 发送一条 waitForConfirms()</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//将channel设为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String msg=<span class="string">"confirm msg"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        <span class="comment">//如果没收到confirm，说明发送失败</span></span><br><span class="line">        <span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">            System.out.println(<span class="string">"message send failed!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"success!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">""</span>+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>*批量 发送一批 waitForConfirms<br>如果丢失一条，整批都失败，需要重发</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//将channel设为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        String msg=<span class="string">"confirm msg"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没收到confirm，说明发送失败</span></span><br><span class="line">        <span class="keyword">if</span>(!channel.waitForConfirms())&#123;</span><br><span class="line">            System.out.println(<span class="string">"message send failed!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"success!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>*异步 提供回调,进行监听<br>channel对象提供ConfirmListener()回调方法只包含deliverTag（消息的序列号）,我们需要为每个channel维护一个unconfirm的消息序列号集合，每publish一个数据，集合元素增加1，每会跳一次handleAck方法，unconfirm集合删掉相应的一条或多条记录。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"queue_confirm_3"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel= ConnectionUtils.getChan();</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将channel设为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">//存放未确认的消息</span></span><br><span class="line">        <span class="keyword">final</span> SortedSet&lt;Long&gt; confirmSet= Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">//handNack 回执有问题</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleNack---multiple"</span>);</span><br><span class="line">                    confirmSet.headSet(deliveryTag+<span class="number">1</span>).clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleNack---multiple false"</span>);</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有问题的handleAck</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleAack---multiple"</span>);</span><br><span class="line">                    confirmSet.headSet(deliveryTag+<span class="number">1</span>).clear();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"---handleAack---multiple false"</span>);</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String msg=<span class="string">"confirm msg"</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> seqNo=channel.getNextPublishSeqNo();</span><br><span class="line">            confirmSet.add(seqNo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="整合到Spring-Cloud里的用法"><a href="#整合到Spring-Cloud里的用法" class="headerlink" title="整合到Spring Cloud里的用法"></a>整合到Spring Cloud里的用法</h2><p>之前讲了rabbit的原生用法，现在我们要结合spring cloud Stream使用，</p>
<h3 id="Qucik-Start"><a href="#Qucik-Start" class="headerlink" title="Qucik Start"></a>Qucik Start</h3><p>基于springboot 构建一个微服务，使用消息中间件rabbitMQ接受消息并打印到日志。<br>1）建立stream-hello工程<br>2）pom导入</p>
<pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre><p>3)建立消息接受类</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Sink.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"recieved"</span>+payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>4)主类不变，然后启动。不需要做任何配置！</p>
<p>可以看到控制台的Connections多了一条，我们通过Queues里的发布消息来发布一条，<br>可以看到程序控制台打印了</p>
<pre><code>recieved[B@6a001153
</code></pre><p>我们来看一下是如何实现的。<br>1.spring boot应用引入stream-rabbit的依赖，是stream对rabbitMQ的支持的封装，包含了对rabbitMQ的自动配置等内容；等价于stream-binder-rabbit<br>2.Stream的核心注解被定义在SinkReciever中</p>
<pre><code>1.@EnableBinding用来注解一个或多个定义了@Input @Output的接口。我们绑定了Sink接口，这个接口是spring cloud stream默认实现输入消息的绑定通道
含义就是这个类绑定了一个input通道
2.@StreamListener
通过该注解将receive方法注册为input通道的监听处理器，在rabbit发布消息的时候，receive会做出相应的相应动作
</code></pre><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>Spring Cloud Stream结构图。<br><img src="/2018/04/20/06-大后端-05架构-02微服务-01Spring-Cloud-08-Bus/6.jpg" title="Stream结构图"><br>Stream构建的应用程序与消息中间件是通过Binder关联起来，实现中间件与应用程序的解耦。对于每一个Stream来说，只需要知道Binder对应用程序提供的抽象概念Channel来使用消息中间件来实现逻辑即可</p>
<h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>各个消息中间件差异较大，如果没有Binder这一层，消息交互将变得很笨重，对具体中间件实现细节依赖严重。有了Binder，只需要暴露统一的Channel通道，更换消息队列也只需要更换对应的Binder即可。<br>而且快速入门的时候，并没有做任何rabbit配置。秉承了spring boot的理念，对rabbit做了自动化配置。当然我们也可以修改</p>
<pre><code>spring.cloud.stream.binding.input.destination=raw-sensor-data
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=cg
spring.rabbitmq.password=123456
</code></pre><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>stream消息通信遵循了发布订阅。一条消息投递到中间件后，会通过通向topic主题进行广播，订阅者收到它并触发自身的业务逻辑进行处理。不同的消息中间件topic对应不用的概念<br>rabbitmq中topic对应exchange网关<br>kafka中topic对应topic</p>
<p>1）quick start中，我们通过channel发布消息给应用程序。<br>2）stream应用启动时候，@EnableBinding(Skin.class)<br>在rabbitmq的exchange中也创建了一个名为input的exchange交换器，我们可以在控制台看到<br>3）我们通过不同端口号启动两个示例程序，可以看到exchange中input里绑定了两个channel<br>这种模式就是之前的那个rabbit6大模式之中的topic模式，消息通过exchange，exchange上绑定了多个不同的队列，一个队列对应一个接受方</p>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p>微服务架构中，实际上每一个微服务应用为了高可用和负载均衡，均会部署多个实例。<br>这种情况下，消息生产者发送消息给某个具体微服务实例时，只希望被消费一次，但是像刚才那种启动两个实例，消息会被消费两次。这时候我们需要用到消费组这个概念。<br>如果一个服务有多个实例的时候，我们可以通过配置</p>
<pre><code>spring.cloud.stream.bindings.input.group
</code></pre><p>为其制定一个组名。只有一个成员真正接收消息并处理，而不会出现多次处理的情况。<br>实际应用最好给服务指定一个消费组，防止消费重复处理！除非那种全局都需要处理的情况，比如刷新配置</p>
<h4 id="消息分区"><a href="#消息分区" class="headerlink" title="消息分区"></a>消息分区</h4><p>通过消费组，可以使消息只被一个实例处理，但是无法控制被哪个实例使用。情况就是，同一个消息，多次到达后可能被不同的机器消费处理。这种情况对与一些需要事务控制或者用于持续报告的监控服务时，会将数据分散到各个节点而导致不一致性，这种情况需要进行消息分区。<br>这种分区通过stream提供的通用的抽象实现，所有对于消息中间件是否支持分区不关心。<br>通过配置<br>1）消费者配置<br>spring.cloud.stream.bindings.input.destination 开启分区<br>spring.cloud.stream.instanceConut=2 指定当前消费组实例数量<br>spring.cloud.stream.instanceInedex 设置当前实例索引号<br>2）生产消息也需要配置相应修改<br>spring.cloud.stream.bindings.output.destination 开启分区<br>spring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload<br>spring.cloud.stream.bindings.output.producer.partitionCount=2</p>
<hr>
<h1 id="Kafka实现"><a href="#Kafka实现" class="headerlink" title="Kafka实现"></a>Kafka实现</h1><p>kafaka使用Scala实现，基于消息发布-订阅模式实现。一般经常用来处理日志，流计算或者ELK处理<br><em>消息持久化：时间复杂度1的方式提供消息持久化能力TB级别
</em>高吞吐：廉价机器10万+<br><em>分布式：消息分区，分布式消费
</em>跨平台：支持java python等<br>*实时性：可以实时数据处理及离线数据处理</p>
<h2 id="kafaka基本概念"><a href="#kafaka基本概念" class="headerlink" title="kafaka基本概念"></a>kafaka基本概念</h2><p><em>Broker：Kafaka集群中的一个节点服务器 
</em>Topic：每条发送到kafaka集群的消息必须有一个topic<br><em>Partition：分区，为了提升吞吐容量，每个topic会分成一个或多个Partition，每个Partition对相应一个文件夹 Producer 不解释
</em>Consumer 不解释<br>*Consumer Group 一组特定得消费者</p>
<h2 id="kafaka-安装配置"><a href="#kafaka-安装配置" class="headerlink" title="kafaka 安装配置"></a>kafaka 安装配置</h2><p>我们再cent 7上来进行<br>1需要jdk，在这使用openjdk</p>
<pre><code>rpm -qa |grep java
rpm -qa |grep jdk
rpm -qa |grep gcj
如果没有输入信息表示没有安装。
如果安装可以使用rpm -qa | grep java | xargs rpm -e --nodeps 批量卸载所有带有Java的文件  这句命令的关键字是java
首先检索包含java的列表
yum list java*
检索1.8的列表
yum list java-1.8*
安装1.8.0的所有文件
yum install java-1.8.0-openjdk* -y
使用命令检查是否安装成功
java -version
</code></pre><p>2.下载kafka<br>*解压</p>
<pre><code>tar -zxvf kafka_2.10-0.10.0.1.tgz
</code></pre><p>*移动到指定目录</p>
<pre><code>mv kafka_2.10-0.10.0.1 /usr/local/kafka
</code></pre><p>*启动zookeeper</p>
<pre><code>/usr/local/kafka/bin/zookeeper-server-start.sh -daemon /usr/local/kafka/config/zookeeper.properties
</code></pre><p>*启动kakfka</p>
<pre><code>/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties
</code></pre><p>*创建topic</p>
<pre><code>/usr/local/kafka/bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
</code></pre><p>*产生消息</p>
<pre><code>/usr/local/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test

hello cg kafka！
</code></pre><p>*消费消息</p>
<pre><code>/usr/local/kafka/bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/06-大后端-05架构-02微服务-01Spring-Cloud-07-Config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/06-大后端-05架构-02微服务-01Spring-Cloud-07-Config/" itemprop="url">02、微服务-01、Spring Cloud之07、Config</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T09:48:22Z">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring Cloud Config是用来为分布式系统中基础设施和微服务提供集中化外部配置的支持，分为客户端和服务端。<br>*客户端：微服务的各个微服务应用</p>
<pre><code>通过指定的配置中心来管理应用资源与业务的配置内容，启动时从配置中心获取加载配置信息
</code></pre><p>*服务端：分布式配置中心</p>
<pre><code>独立的微服务应用，连接配置仓库，为客户端获取配置信息。默认采用Git
</code></pre><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>构建一个Git分布式配置中心，并在客户端中通过配置中心获取配置</p>
<h2 id="配置中心构建"><a href="#配置中心构建" class="headerlink" title="配置中心构建"></a>配置中心构建</h2><h3 id="1）springboot-pom引入config-server即可"><a href="#1）springboot-pom引入config-server即可" class="headerlink" title="1）springboot pom引入config-server即可"></a>1）springboot pom引入config-server即可</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.M9<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="主类及配置"><a href="#主类及配置" class="headerlink" title="主类及配置"></a>主类及配置</h3><p>主类加入@EnableConfigServer、同时配置congfig中心</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=7001</span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/nijigenCG/SpringCloud-Learn/</span><br><span class="line">spring.cloud.config.server.git.searchPaths=config-repo</span><br><span class="line">spring.cloud.config.server.git.username=*****</span><br><span class="line">spring.cloud.config.server.git.password=*****</span><br></pre></td></tr></table></figure>
<p>然后我们在git上新建仓库SpringCloud-Learn，仓库下建立文件夹config-repo,文件夹下放入配置文件<br>*config.properties</p>
<pre><code>form=git-default-1.0
</code></pre><p>*config-dev.properties</p>
<pre><code>form=git-dev-1.0
</code></pre><p>*config-test.properties</p>
<pre><code>form=git-test-1.0
</code></pre><h3 id="启动应用看结果"><a href="#启动应用看结果" class="headerlink" title="启动应用看结果"></a>启动应用看结果</h3><p>可以通过如下几种方式获取配置信息，其中master为主分支名，如果有其它分支，只需要改为相应的分支名<br><em><a href="http://localhost:7001/config/dev/master" target="_blank" rel="noopener">http://localhost:7001/config/dev/master</a>
</em><a href="http://localhost:7001/config/master" target="_blank" rel="noopener">http://localhost:7001/config/master</a><br><em><a href="http://localhost:7001/config/test/master" target="_blank" rel="noopener">http://localhost:7001/config/test/master</a>
</em><a href="http://localhost:7001/master/config.properties" target="_blank" rel="noopener">http://localhost:7001/master/config.properties</a></p>
<p>可以看到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: "config",</span><br><span class="line">    profiles: [</span><br><span class="line">        <span class="string">"test"</span></span><br><span class="line">    ],</span><br><span class="line">    label: "master",</span><br><span class="line">    version: "03994b44d95897ae55dcf6f240e71c8d6e26c064",</span><br><span class="line">    state: null,</span><br><span class="line">    propertySources: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: "https://github.com/nijigenCG/SpringCloud-Learn//config-repo/config-test.properties",</span><br><span class="line">            source: &#123;</span><br><span class="line">            from: "git-test-1.0"</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: "https://github.com/nijigenCG/SpringCloud-Learn//config-repo/config.properties",</span><br><span class="line">            source: &#123;</span><br><span class="line">            from: "git-default-1.0"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>config-server从Git获取后，会在本质相应地储存一份文件，实际上通过git clone命令复制了一个副本，然后返回给微服务进行加载。这样可以防止git崩坏掉无法获取配置。</p>
<h2 id="客户端配置映射"><a href="#客户端配置映射" class="headerlink" title="客户端配置映射"></a>客户端配置映射</h2><p>有了提供配置的配置中心，如何让客户端去获取配置</p>
<h3 id="新建spring-boot-项目"><a href="#新建spring-boot-项目" class="headerlink" title="新建spring boot 项目"></a>新建spring boot 项目</h3><p>命名为config-client，引入web和config-client</p>
<h3 id="新建测试类"><a href="#新建测试类" class="headerlink" title="新建测试类"></a>新建测试类</h3><p>建立common包，建立接口类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">//可以使用@Value绑定配置服务中心的from属性</span></span><br><span class="line"><span class="comment">//也可以使用Environment获取配置属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/from"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> env.getProperty(<span class="string">"from"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/from2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"版本信息"</span>+from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bootstrap-properties-一定新建一个新的"><a href="#bootstrap-properties-一定新建一个新的" class="headerlink" title="bootstrap.properties 一定新建一个新的"></a>bootstrap.properties 一定新建一个新的</h3><pre><code>#spring.application.name必须为配置中的xx-aa.properties的xx，否则会value注入会报错。
spring.application.name=config
#spring.cloud.config.profile必须为配置中的xx-aa.properties的aa
spring.cloud.config.profile=test
spring.cloud.config.label=master
spring.cloud.config.uri=http://localhost:7001/

server.port=7002
</code></pre><h3 id="启动看结果"><a href="#启动看结果" class="headerlink" title="启动看结果"></a>启动看结果</h3><p><em><a href="http://localhost:7002/from2" target="_blank" rel="noopener">http://localhost:7002/from2</a><br>    版本信息git-test-1.0
</em><a href="http://localhost:7002/from1" target="_blank" rel="noopener">http://localhost:7002/from1</a><br>    git-test-1.0</p>
<h2 id="服务端详细"><a href="#服务端详细" class="headerlink" title="服务端详细"></a>服务端详细</h2><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><img src="/2018/04/17/06-大后端-05架构-02微服务-01Spring-Cloud-07-Config/1.jpg" title="spring cloud config 结构图">
<p><strong>包含如下几个要素</strong>：<br><em>远程Git仓库
</em>Config Server<br><em>本地Git仓库：存放获取的Git配置本地
</em>Server A、Server B<br><strong>获取配置流程</strong>：<br><em>启动应用，根据bootstrap.properties中的{application应用名}、{profile环境名}、{label分支名}，向config Server发起请求
</em>Config Server维护自己的Git仓库，查找相应配置信息，通过git clone下载到文件系统<br><em>Config Server创建ApplicationContext实例，从Git本地仓库加载配置文件，返回给用户端
</em>客户端获取外部配置文件后加载到客户端的ApplicationContext实例中，优先加载外部，外部配置加载完毕后再加载本地配置</p>
<h3 id="Git仓库配置"><a href="#Git仓库配置" class="headerlink" title="Git仓库配置"></a>Git仓库配置</h3><p>Git的版本控制很好的与config服务进行融合，一个应用不同的部署实例可以轻松获取springcloudconfig的不同版本配置。<br>Git配置可以参照前面，同样也可以脱离Git比如；</p>
<pre><code>#使用本地仓库，脱离Git服务端，快速调试开发
spring.cloud.config.server.git.url=file://${user.home}/config-repo
</code></pre><h3 id="本地文件系统"><a href="#本地文件系统" class="headerlink" title="本地文件系统"></a>本地文件系统</h3><p>不使用Git，需要设置</p>
<pre><code>spring.profiles.active=native
</code></pre><p>Config server会默认从应用的src/main/resource下搜索配置文件。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>配置中心内容敏感，结合Spring Security可以实现<br><em>pom中引入security
</em>在配置文件中指定用户名密码</p>
<pre><code>security.user.name=user
security.user.password=f4s8f1w9fs
</code></pre><p>启动config-server，可以访问<a href="http://localhost:7001/config/test/master" target="_blank" rel="noopener">http://localhost:7001/config/test/master</a><br>会跳转到登陆页面<br>*启动客户端，客户端访问不到配置中心的配置，启动时就会报错</p>
<pre><code>spring.cloud.config.username=user
spring.cloud.config.password=f4s8f1w9fs
</code></pre><p>做了用户名密码校验后可以</p>
<h3 id="高可用配置中心"><a href="#高可用配置中心" class="headerlink" title="高可用配置中心"></a>高可用配置中心</h3><p>有两种模式可以实现<br><em>传统模式：<br>多个config服务器，将指向同一个Git仓库，客户端通过config服务器的负载均衡器获取配置
</em>服务模式：<br>将config作为微服务纳入eureka</p>
<h3 id="config-server改造"><a href="#config-server改造" class="headerlink" title="config server改造"></a>config server改造</h3><p>接下来，我们来看如何将config加入到eureka中<br>改造开始：</p>
<p><em>config server pom增加eureka
</em>application.properties配置添加</p>
<pre><code>eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka/
</code></pre><p><em>主类添加@EnableDiscoveryClient
</em>启动eureka和config server，可以看到注册上了</p>
<h3 id="client改造"><a href="#client改造" class="headerlink" title="client改造"></a>client改造</h3><p><em>pom引入eureka
</em>bootstrap.properties中增加配置</p>
<pre><code>spring.application.name=config
server.port=7002

spring.cloud.config.discovery.enabled=true
spring.cloud.config.discovery.service-id=CONFIG-SERVER
spring.cloud.config.profile=test

eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka/
</code></pre><p><em>主类添加@EnableDiscoveryClient
</em>启动，按之前的访问/from、/from2接口，可以看到实现了</p>
<h2 id="动态刷新配置"><a href="#动态刷新配置" class="headerlink" title="动态刷新配置"></a>动态刷新配置</h2><p>spring cloud config可以实现实时更新配置，我们接着来改造。我们刚才启动的项目，访问/from<br>可以获取到</p>
<pre><code>git-test-1.0
</code></pre><p>修改配种后Git推送出去，发现访问/from还是没有发生变化。<br>需要修改配置。在clien端开启动态刷新<br>*client中新增actuator监控模块</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重启即可！<br>我们通过对client Post请求localhost:7002/refresh然后再访问可看到更新完成</p>
<p>改功能可以同Git仓库的WebHook进行关联，当Git提交变化时，就向相应的阻止发送/refresh post请求。<br>问题来了，系统壮大后，维护配置刷新也会造成系统负担，而且容易犯错，如何解决复杂度？<br>我们需要<strong>SpringCloudBus</strong>来实现以消息总线的反思进行配置变更通知！<br>接下来继续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/01javaSE-21-JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/01javaSE-21-JVM/" itemprop="url">21、JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T17:08:34Z">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/01-JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">-01.JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>author：ChenGong</p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>当前使用的默认为hotspot虚拟机，为sun公司早期收购的。<br>java各种虚拟机历史</p>
<pre><code>1）Sun Classic/Exact VM 已经凉了
    第一台商用java虚拟机，只能用纯解释器执行java代码，效率地下
2）HotSpot
    目前JDK默认虚拟机，使用最广泛
3）移动端嵌入式的VM
    KVM安卓IOS中使用过；
    GoogleAndroidDalvikVM
</code></pre><p>越来越多的其他语言也运用在JVM上如Groovy、Kotlin、Scala</p>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><img src="/2018/04/03/01javaSE-21-JVM/1.png" title="JVM内存结构">
<p>1）线程栈、虚拟机栈stack</p>
<pre><code>jvm参数 -XSS
每个线程都有一个栈空间，线程调用一个方法对应一个栈帧：
a）局部变量表；编译期间就能决定大小，一个固定大小的内存区块，不运行就没有数据；
b）操作树栈：
new出来在堆
</code></pre><p>2）堆heap</p>
<pre><code>分为新生代（分为三块eden，survivor，survivor），老年代（tenured）
--new对象，普通放new中的eden，大的放old
--Gc一次后，还被引用，从eden放到第一个survivor，第二个survivor为空，则接收下一次eden
--Gc一次后，还被引用，复制到第二个survivor，第一个survivor变为空，则接收下一次eden；两个survivor不断转换，不停来回拷贝。内存复制速度效率高
--经过很多次都没回收，放入tenured；
</code></pre><p>3）静态方法区（java8叫永久区perm）<br>    用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>4）程序计数器<br>    指向当前线程正在执行的字节码指令的地址，行号。<br>    （jvm最小执行单位是线程，线程在cpu中是一个时间片。线程a占了时间片资源，是会被抢占的，一旦时间片被抢，会被挂起，没有程序计数器的话，则找不到地方被唤醒，所以要指向）<br>5）本地方法栈</p>
<p>二、jvm参数</p>
<pre><code>-      标准参数
</code></pre><p>-x     非标准参数<br>-xx    不稳定参数</p>
<p>三、java对象分配<br>New一个对象，如果很小且开了栈上分配（server模式默认开启）优化，则会首先分配在栈上，如果栈上不能分配就线程就再根据对象大小选择分配在老年代或者eden<br>1）栈上分配<br>    线程私有小对象<br>    无逃逸（指对象只被当前引用）<br>    支持标量替换<br>    无需调整<br>2）线程本地分配TLAB<br>    （每个线程都会开辟自己的私有栈空间，如果不开启则会放到eden区，每个对象需要加锁。）<br>    占用eden，默认1%<br>    多线程不用竞争eden就可以申请空间，提高效率<br>    小对象<br>    无需调整<br>3）老年代<br>    大对象<br>4）eden</p>
<p>eg：循环100000次new对象，<br>执行：run  -XX:-DoEscapeAnalysis  -XX:-EliminateAllocation -XX：-UseTLAB -XX：+PrintGC<br>表示关闭逃逸分析，关闭标签替换，关闭线程本地内存<br>然后依次打开观察执行情况</p>
<h1 id="堆内存的垃圾回收机制"><a href="#堆内存的垃圾回收机制" class="headerlink" title="堆内存的垃圾回收机制"></a>堆内存的垃圾回收机制</h1><p>一、基本知识<br>1）GC什么是垃圾，如何确定垃圾<br>没有引用指向的对象。或者相互指向或者环形指向的。<br>书面叫引用技术，正向可达<br>2）软应用 弱引用 虚引用 强引用<br>a）强引用：只要引用存在，垃圾回收器永远不会回收<br>b）软引用：非必须引用，内存溢出之前进行回收，可以通过以下代码实现<br>    Object obj = new Object();<br>    SoftReference<object> sf = new SoftReference<object>(obj);<br>    obj = null;<br>    sf.get();//有时候会返回null<br>    这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；<br>    软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。<br>c）弱引用<br>    第二次垃圾回收时回收，可以通过如下代码实现<br>    Object obj = new Object();<br>    WeakReference<object> wf = new WeakReference<object>(obj);<br>    obj = null;<br>    wf.get();//有时候会返回null<br>    wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾<br>    弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。<br>    弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。<br>d）虚引用<br>    垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现<br>    Object obj = new Object();<br>    PhantomReference<object> pf = new PhantomReference<object>(obj);<br>    obj=null;<br>    pf.get();//永远返回null<br>    pf.isEnQueued();//返回是否从内存中已经删除<br>    虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。<br>    虚引用主要用于检测对象是否已经从内存中删除。<br>3）垃圾回收算法<br>a）Mark-Sweep标记清除，现以不用<br><img src="/2018/04/03/01javaSE-21-JVM/2.png"><br>    缺陷：造成内存的不连续，突然来一个大的对象，找不到内存适合的空间，就会造成fullGC<br>b）Copying复制  效率高，新生代<br><img src="/2018/04/03/01javaSE-21-JVM/3.png"><br>    效率非常高，但是浪费内存</object></object></object></object></object></object></p>
<p>c）Mark-Compact标记压缩  效率略低，老年代<br><img src="/2018/04/03/01javaSE-21-JVM/4.png"><br>    将不是垃圾的向一端压缩，一般用到老年代</p>
<pre><code>综合以上，分配比例8：1：1
    Survivor不能设大了，浪费内存。
    eden 因为绝大部分会被回收，只有少部分会被复制到surviver，效率非常高
    Old很难呗回收，所以老年代需要设置大些。
new：old  1：3
</code></pre><p>二、垃圾收集器<br>1）Seial Collector 凉了<br>    单线程，吞吐量到100MB，不支持多处理器，引用少<br>2）parallel Collector<br>    Jdk8默认的，效率高，吞吐量大，垃圾收集时会停顿！<br>3）Mostly Concurrent Collector两种<br>    并发收集器，不单单是并发<br>    a）UseConcMarkSweepGC<br><img src="/2018/04/03/01javaSE-21-JVM/5.png"><br>        以获取最短回收停顿时间为目标的收集器，采用mark-sweep<br>            1）初始标记<br>            2）并发标记<br>            3）重新标记<br>            4）并发清除<br>          初始标记、从新标记这两个步骤仍然需要“stop the world”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，熟读很快，并发标记阶段就是进行GC Roots Tracing，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。<br>        缺点：<br>        1）CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。<br>        2）CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。<br>        浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。<br>        3）CMS是一款“标记–清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。<br>    b）G1GC java9默认             不仅停顿短还并发大<br><img src="/2018/04/03/01javaSE-21-JVM/6.png"><br>        G1是一款面向服务端应用的垃圾收集器。G1具备如下特点：<br>        1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。<br>        2、分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。<br>        3、空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。<br>        4、可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，<br>        5、G1运作步骤：<br>        1、初始标记；2、并发标记；3、最终标记；4、筛选回收<br>        上面几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短，并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>
<h1 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务-00SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务-00SpringBoot/" itemprop="url">02、微服务-00、Spring Boot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:54Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>做过Spring项目都知道，繁复的配置，各种properties，xml让项目构建十分枯燥。pom文件错综复杂的依赖！<br>SpringBoot可通过自动化配置，极大地简化项目的构建成本，可以说5分钟构建项目！而如今容器化大行其道，SpringBoot可以很好融入Docker。内嵌容器，可打包成jar，通过java -jar命令直接运行，方便跨平台部署。</p>
<ol>
<li>自动配置</li>
<li>起步依赖spring-boot-starter：，Spring Boot的起步依赖还把你从”需要这些库的哪些版本”这个问题里解放了出来</li>
<li>CLI</li>
<li>Actuator：在运行时检视应用程序内部情况</li>
</ol>
<p>SpringBoot2.0新特性</p>
<ol>
<li>java8</li>
<li>spring 5.0</li>
<li>Web Flux （函数式编程 java8 lambda，响应式编程Reactive Streams，异步编程 Servlet3.1 NIO）</li>
</ol>
<h2 id="快速构建一个项目"><a href="#快速构建一个项目" class="headerlink" title="快速构建一个项目"></a>快速构建一个项目</h2><h3 id="构件过程"><a href="#构件过程" class="headerlink" title="构件过程"></a>构件过程</h3><p>IDEA直接new一个SpringBoot项目即可！导包形式选择jar<br>了解一下项目结构</p>
<pre><code>pom文件中项目依赖:
不再像以前的spring配置，大量依赖，还要到处去找配置文件复制。
直接使用starter POMs定义的依赖包，这些spring boot已经为你做好了
spring-boot-starter-web和spring-boot-starter-test
如果我们再整合其他模块。比如
连接数据库直接引入：spring-boot-starter-jdbc
</code></pre><p>以main方法为项目入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crud同传统项目类似controller-service-dao，我们建立一个REST-Controller<br>注意：SpringBootCrudApplication要放在所有包外面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world spring boot"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"get"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">get</span><span class="params">(@RequestParam(value=<span class="string">"name"</span>)</span>String name) </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, name);</span><br><span class="line">    map.put(<span class="string">"value"</span>, <span class="string">"hello spring boot"</span>);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"getModel/&#123;name&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Users <span class="title">getUser</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">    Users user=<span class="keyword">new</span> Users();</span><br><span class="line">    user.setName(name);</span><br><span class="line">    user.setAge((<span class="keyword">int</span>) Math.random());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后来编写单元测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootCrudApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line">    <span class="comment">//使用spring测试类将自己的方法引入</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvc=MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> DemoController()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RequestBuilder req=get(<span class="string">"/"</span>);</span><br><span class="line">        mvc.perform(req).andExpect(content().string(<span class="string">"hello world spring boot"</span>)).andExpect(status().isOk());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后打包</p>
<pre><code>Run as maven build
Cmd进入目录 java -jar spring-boot-demo.jar
</code></pre><h3 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h3><ol>
<li><p>版本管理<br>新建的spring boot项目 &gt;父项目<br>spring-boot-starter-parent &gt; 父项目<br>spring-boot-dependencies （版本中心）<br>spring-boot-dependencies pom在properties中定义好了所有jar的版本依赖。所以导入依赖不再需要写版本号，除非该jar不在spring-boot-dependencies中管理<br>springboot将一个个依赖抽取出来，做成各种starters</p>
</li>
<li><p>@SpringBootApplication</p>
</li>
</ol>
<p>SpringBootApplication注解事实上包含两个主要的注解：一个是扫描，一个是注入自动配置类</p>
<ul>
<li>---@SpringBootConfiguration  //底层为Spring框架 @Configuration 注解类</li>
<li>---@EnableAutoConfiguration  //开启自动配置<br>  包含@AutoConfigurationPackage  ----@Import({Registrar.class})<pre><code>@Import({AutoConfigurationImportSelector.class})
</code></pre>所以EnableAutoConfiguration是由Registrar和AutoConfigurationImportSelector来完成的</li>
</ul>
<p><strong>Registrar</strong> 类中跟registerBeanDefinitions方法的断点，可发现通过ClassUtils.getPackageName(metadata.getClassName()) 将著配置类的注解所在的包找到 — 然后扫描所有组件。所以，写的内的包都必须在主类同路径<br><strong>AutoConfigurationImportSelector</strong> 类selectImports方法断点，List<string> configurations = this.getCandidateConfigurations(annotationMetadata, attributes); getCandidateConfigurations 方法通过 SpringFactoriesLoader.loadFactoryNames —  再通过资源获取器获取  classLoader.getResources(“META-INF/spring.factories”)  — 每个starter的jar下均有该默认配置META-INF/spring.factories</string></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>1) spring boot 主方法开启@EnableAutoConfiguration<br>2) @EnableAutoConfiguration</p>
<ul>
<li>EnableAutoConfigurationImportSelector给容器导入组件。</li>
<li>可以用selectImports()方法的内容</li>
<li><p>List<string> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</string></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描所有jar下的MATE-INF/spring.factories</span></span><br><span class="line">SpringFactoriesLoder.loadFactoryNames()</span><br><span class="line"><span class="comment">//将扫描的文件内容包装为Properties对象</span></span><br><span class="line"><span class="comment">//从Properties获取值。然后添加在容器中</span></span><br></pre></td></tr></table></figure>
<p>  spring boot autoconfiguration jar下面</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>  以上每一个xxxautoconfigure都加进去，做自动配置<br>3) 以上每一个自动配置类均进行自动配置，以HttpEncodingAutoConfiguration为例。org\springframework\boot\autoconfigure\web\servlet\HttpEncodingAutoConfiguration.class</p>
</li>
</ul>
<p>这些自动配置类均在autoconfiguration jar包下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启用ConfigurationProperties功能，指向注解类，从注解类获取配置</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpEncodingProperties.class&#125;)</span><br><span class="line"><span class="comment">//满足条件才生效配置</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line"><span class="comment">//判断当前类有没有CharacterEncodingFilter.class，有才加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;CharacterEncodingFilter.class&#125;)</span><br><span class="line"><span class="comment">//判断配置文件中是否存在配置，matchIfMissing= true 如果没配置也生效的意思</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    prefix = <span class="string">"spring.http.encoding"</span>,</span><br><span class="line">    value = &#123;<span class="string">"enabled"</span>&#125;,</span><br><span class="line">    matchIfMissing = <span class="keyword">true</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>4)所有默认配置均封装在xxxProperties类中，如HttpEncodingProperties.class</p>
<h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><p>SpringBoot支持yaml配置。 yaml:后有空格，且不要用Tab；对其的均为一个层级<br>application.yaml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    context-path:</span> <span class="string">/helloboot</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure></p>
<h3 id="将配置值注入到bean-ConfigurationProperties和-Value"><a href="#将配置值注入到bean-ConfigurationProperties和-Value" class="headerlink" title="将配置值注入到bean @ConfigurationProperties和@Value"></a>将配置值注入到bean @ConfigurationProperties和@Value</h3><ol>
<li><p>@ConfigurationProperties<br>springboot获取yaml配置值的方式，<br>首先导入配置文件处理器spring-boot-configuration-processor<br>然后通过@ConfigurationProperties将配置文件中的值注入到bean中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"xxx"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rtesat</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Value</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rtesat</span></span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"lisi"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>全局Profile配置我们使用application-{profile}.properties来定义，<br>然后在application.properties中通过spring.profiles.active来指定使用哪个Profile。</p>
<ol>
<li><p>在src/main/resources文件夹下定义不同环境下的Profile配置文件，<br>文件名分别为application-prod.properties和application-dev.properties，这两个前者表示生产环境下的配置，后者表示开发环境下的配置：</p>
<p> application-prod.properties:<br> server.port=8081</p>
<p> application-dev.properties:<br> server.port=8080</p>
</li>
<li><p>然后在application.properties中进行简单配置，如下：</p>
<p> spring.profiles.active=dev<br>这个表示使用开发环境下的配置。然后运行项目，我们得通过8080端口才可以访问：<br>如果想换为生产环境，只需要把spring.profiles.active=dev改为spring.profiles.active=prod即可，当然访问端口这是也变为8081了</p>
</li>
<li><p>发布后切换</p>
<p> Cmd进入目录 java -jar spring-boot-demo.jar–spring.profile.active=dev</p>
</li>
</ol>
<h3 id="定制banner"><a href="#定制banner" class="headerlink" title="定制banner"></a>定制banner</h3><p>我们在启动Spring Boot项目的时候，在控制台会默认输出一个启动图案，SPRING<br>这个图案如果需要的话是可以自己修改的，修改方式很简单：</p>
<pre><code>1.在src/main/resources下新建一个banner.txt文档
2.通过http://patorjk.com/software/taag网站生成需要的字符，
将字符拷贝到步骤1所创建的txt文档中，比如我这里为Hello CG！生成字符
</code></pre><p>使用随机数<br>一些特殊情况，希望有些参数每次加载不要一样，比如密钥等，可以通过${random}产生</p>
<pre><code> #随机字符串
com.cg.blog.value=${random.value}
 #随机int
com.cg.blog.value=${random.int}
 #随机long
com.cg.blog.value=${random.long}
 #随机10以内
com.cg.blog.value=${random.int(10)}
 #随机10~20
com.cg.blog.value=${random.int(10,20)}
</code></pre><p>命令行参数<br>java -jar xxxx.jar 运行时，可对配置文件中进行赋值</p>
<pre><code>java -jar xxxx.jar--server.port=8988
java -jar xxxx.jar--spring.profile.active=dev
</code></pre><h3 id="SpringBoot配置加载顺序"><a href="#SpringBoot配置加载顺序" class="headerlink" title="SpringBoot配置加载顺序"></a>SpringBoot配置加载顺序</h3><p>大致的有  </p>
<pre><code>源码文件下的config目录下的配置 &gt; 
源码文件根目录下的配置 &gt; 
resource目录下的config目录的配置 &gt; 
resource根目录的配置
</code></pre><p>详细的有</p>
<pre><code>命令行参数 &gt; 
SPING_APPLICATION_JSON &gt; 
java:comp/env &gt;...

jar 包外 针对不同{profile} &gt; (放在jar同一路径下，用java -jar不带任何参数启动即可)
jar 包内 针对不同{profile} &gt; 
jar 包外 application.properties &gt; 
jar 包内 application.properties&gt; 
默认
</code></pre><p>看看出，SpringBoot可实现从外部配置，工程类的配置非常干净！不用关心其他环境配置，由对应的负责人维护配置<br>SpringCloudConfig也基于此。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志（推荐logback）"><a href="#日志（推荐logback）" class="headerlink" title="日志（推荐logback）"></a>日志（推荐logback）</h3><p>默认情况下Spring Boot使用Logback作为日志框架，如果有需要我们可以手动配置日志级别以及日志输出位置，相比于我们在Spring容器中写的日志输出代码，这里的配置简直就是小儿科了，只需要在application.properties中添加如下代码：</p>
<pre><code>logging.file=/home/sang/workspace/log.log
logging.level.org.springframework.web=debug
</code></pre><p>上面表示配置日志输出位置，下面配置日志级别。</p>
<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-06 Zuul/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-06 Zuul/" itemprop="url">02、微服务-01、Spring Cloud之06、Zuul</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:40Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：集中式传统web开发者，熟悉SpringBoot后可开袋食用！<br>author：ChenGong<br>本文为笔记向！</p>
<h1 id="Zuul网关"><a href="#Zuul网关" class="headerlink" title="Zuul网关"></a>Zuul网关</h1><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-06%20Zuul/8.jpg" title="系统架构">
<p>内部service通过服务注册发现相互调用，还有对外的OpenService，提供对外RESTful API服务，通过Nginx等进行负载均衡后提供给外部客户端。<br>一、但是为了让路由正确分发，实例增减或ip变动等发生的情况，需要手动同步维护，系统规模大是，维护及其不便。<br>二、对外服务会有权限校验等机制，如用户登陆等，为了防止客户端发起请求时被篡改等，还会有签名校验机制。微服务将原本单一的应用拆成了多个应用，我们不得不在每个应用中去实现这样一套逻辑，这些校验代码非常冗余。一旦修改逻辑，需要将所有的应用上的逻辑进行修改。<br>所有我们需要API网关，所有外部客户端访问都需要经过它来进行过滤调度！</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>Zuul通过服务注册中心注册到Eureka，从而获取到服务实例。Zuul会默认通过以服务名作为ContextPath方式来创建映射。<br>对于签名校验，登陆等问题，完全可以做成独立的服务，从应用中剥离，在API网关服务上进行统一的调用来对服务接口做前置过滤。可以通过ZUul创建校验过滤器，指定哪些规则需要执行校验逻辑，通过校验才会被路由到具体的微服务接口，使得微服务更加专注于业务逻辑开发。</p>
<h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>我们来新建一个Zuul。<br>spring boot<br>1.pom</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

&lt;groupId&gt;com.cg&lt;/groupId&gt;
&lt;artifactId&gt;api-gateway&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;jar&lt;/packaging&gt;

&lt;name&gt;api-gateway&lt;/name&gt;
&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
        &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;
        &lt;version&gt;2.0.0.M6&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-milestones&lt;/id&gt;
        &lt;name&gt;Spring Milestones&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
&lt;/project&gt;
</code></pre><p>2.主类增加@EnableZuulProxy<br>3.配置</p>
<pre><code>spring.application.name=api-gateway
server.port=5555
#服务实例映射
zuul.routes.api-a-url.path=/api-a/**
zuul.routes.api-a.serviceId=HELLO-SERVER
zuul.routes.api-b-url.path=/api-b/**
zuul.routes.api-b.serviceId=FEIGN-CONSUMER
#zuul注册到eureka
eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka
</code></pre><p>然后我们启动eureka注册中心、hello-server provider、feign-consumer、还有api-gateway<br>已经配置了路由规则。我们访问api的<a href="http://localhost:5555/api-b/feign-consumer" target="_blank" rel="noopener">http://localhost:5555/api-b/feign-consumer</a> .api网关吧请求转发到相应的服务实例上去，只需配置简单的path和serviceId映射组合即可。</p>
<h1 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h1><p>实现请求路由的基本功能后，微服务可以通过统一的API网关作为入口进行访问。但是访问权限等没有限制，任何请求都会被转发，最简单粗暴的是在所有微服务上添加一套权限逻辑，但是不可取。我们需要剥离，形成一个独立的鉴权服务。而Zuul的一个核心功能就是：请求过滤，只需要继承ZuulFilter抽象类并实现4个抽象函数即可完成请求的拦截与过滤。耐看一个简单的Zuul过滤器</p>
<pre><code>public class AccessFilter extends ZuulFilter{
    private static Logger log=LoggerFactory.getLogger(AccessFilter.class);
    //过滤器类型，决定过滤器在什么生命周期中执行，pre代表在请求路由之前进行。
    @Override
    public String filterType(){
        return &quot;pre&quot;;
    }
    //过滤器执行顺序
    @Override
    public int filterOrder(){
        return 0;
    }
    //过滤器是否要被执行，可以制定改函数的过滤器有效范围
    @Override
    public boolean shouldFilter(){
        return true;
    }
    //过滤器逻辑类型，context.setSendZuulResponse(false)命令Zuul过滤该请求，
    //context.setResponseStatusCode(401)返回错误代码
    @Override
    public Object run(){
        RequestContext context=RequestContext.getCurrentContext();
        HttpServletRequest requset=context.getRequset();
        log.info(&quot;send {} request to {}&quot;,requset.getMethod(),requset.getRequsetURL().toString());

        Obeject accessToken=requset.getParamter(&quot;accessToken&quot;);
        if(accessToken==null){
            log.warn(&quot;token empty!!&quot;);
            context.setSendZuulResponse(false);
            context.setResponseStatusCode(401);
            return null;
        }
        log.info(&quot;access token ok!&quot;);
        return null;
    }
}
</code></pre><p>实现过滤器后，不会直接生效，需要创建具体的bean才能启动<br>在主类中增加如下方法才会生效</p>
<pre><code>@Bean
public AccessFilter accessFilter（）{
    return new AccessFilter();
}
</code></pre><p>我们测试</p>
<pre><code>http://localhost:5555/api-a/hello
http://localhost:5555/api-a/hello&amp;accessToken=token
</code></pre><h1 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h1><h2 id="路由的一些基本配置"><a href="#路由的一些基本配置" class="headerlink" title="路由的一些基本配置"></a>路由的一些基本配置</h2><p>回顾一下路由配置</p>
<pre><code>zuul.routes.api-a-url.path=/api-a/**
zuul.routes.api-a.serviceId=HELLO-SERVER
zuul.routes.api-b-url.path=/api-b/**
zuul.routes.api-b.serviceId=FEIGN-CONSUMER
</code></pre><p>除了path与serviceId的映射外，还有更简洁的配置</p>
<pre><code>#zuul.routes.&lt;serviceId&gt;=&lt;path&gt;
zuul.routes.user-service=/user-service/**
#将zuul看作eureka下的一个服务，他会获取所有实例清单，自己就得到了serviceID与服务实例地址的映射，api网关可自动找到最佳匹配
</code></pre><p>虽然eureka与zuul省去了维护服务配置的工作，但是实际情况一般如下</p>
<pre><code>zuul.routes.fegin-consumer.path=/fegin-consumer/**
zuul.routes.fegin-consumer.serviceId=fegin-consumer
</code></pre><p>zuul的默认规则可以完全不需要我们这样一个一个配置。<br>当我们为API网关引入eureka后，每个服务都会创建一个默认的路由规则，path使用serviceId配置的服务名作为请求前缀。<br>由于默认情况eureka的所有服务都会被zuul自动创建映射，而有些我们不希望暴露出去，可以用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.ignore-serices=*</span><br><span class="line">zuul.routes.hello-server.serviceId=hello-server</span><br></pre></td></tr></table></figure>
<p>如上设置一个服务名匹配表达式来定义不自动映射，只需要添加我们想要暴露的服务hello-server，而fegin-consumer则不会暴露出去</p>
<h2 id="自定义路由规则"><a href="#自定义路由规则" class="headerlink" title="自定义路由规则"></a>自定义路由规则</h2><p>构建微服务时，为了兼容不同外部版本，一般会采用开闭原则进行设计开发。我们可以根据服务版本表示来知道，如下<br>userservice-v1、userservice-v2、orderservice-v1、orderservice-v2<br>这样，路由默认会映射成/userservice-v1、/userservice-v2<br>但是这样不利于通过规则进行管理，可以改成如下这样</p>
<pre><code>/v1/userservice
//PatternServiceRouteMapper添加到主类下，通过正则表达式定义路由映射
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">serviceRouteMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(</span><br><span class="line">        <span class="string">"(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)"</span>,</span><br><span class="line">        <span class="string">"$&#123;version&#125;/$&#123;name&#125;"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>可以通过如下来看</p>
<pre><code>/user-service/?     匹配一个/user-service/a、/user-service/d、/user-service/3
/user-service/*     匹配任意/user-service/afdsfs
/user-service/**    匹配任意及多级目录 /user-service/afdsfs、/user-service/afdsfs/zz
</code></pre><h1 id="Zuul过滤器！"><a href="#Zuul过滤器！" class="headerlink" title="Zuul过滤器！"></a>Zuul过滤器！</h1><p>zuul包含对请求路由及过滤两个功能，路由将外部请求转发到微服务实例，过滤将请求进行校验，实现请求校验服务聚合等功能<br>spring cloud zuul包含4个基本特性实际上ZuulFilter中4个抽象方法：</p>
<h2 id="过滤类型-String-filterType"><a href="#过滤类型-String-filterType" class="headerlink" title="过滤类型 String filterType()"></a>过滤类型 String filterType()</h2><p>需要返回一个字符串代表过滤器类型，Zuul默认了4个不同的生命周期过滤类型。</p>
<pre><code>pre：路由请求前调用
routing：请求时调用
post：routing和error过滤器之后调用
error：处理请求时发生错误被调用
</code></pre><p>filterType4种过滤器类型定义了一个外部HTTP到达API网关，直到返回请求结果的全部生命周期。可以通过下图清晰的看出来流转过程<br><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-06%20Zuul/3.png" title="过滤器流转图"><br>这其中为了让API网关可以更方便使用，默认实现类一批核心的过滤器。定义在springcloud core下的netflix.zuul.filters。<br><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-06%20Zuul/4.png" title="过滤器包下结构"></p>
<h2 id="顺序执行-int-filterOrder"><a href="#顺序执行-int-filterOrder" class="headerlink" title="顺序执行 int filterOrder()"></a>顺序执行 int filterOrder()</h2><pre><code>用值越小优先级越高
</code></pre><h2 id="执行条件-boolean-shouldFilter"><a href="#执行条件-boolean-shouldFilter" class="headerlink" title="执行条件 boolean shouldFilter()"></a>执行条件 boolean shouldFilter()</h2><pre><code>是否执行该过滤器
</code></pre><h2 id="具体操作-Object-run"><a href="#具体操作-Object-run" class="headerlink" title="具体操作 Object run()"></a>具体操作 Object run()</h2><pre><code>自定义过滤逻辑，是否要拦截当前请求
</code></pre><h2 id="过滤器生命周期表"><a href="#过滤器生命周期表" class="headerlink" title="过滤器生命周期表"></a>过滤器生命周期表</h2><table>
<thead>
<tr>
<th>顺序</th>
<th>过滤器</th>
<th>功能</th>
<th>阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td>-3</td>
<td>ServletDetectionFilter</td>
<td>标记处理Servlet的类型</td>
<td>pre</td>
</tr>
<tr>
<td>-2</td>
<td>Servlet30WrapperFilter</td>
<td>包装HttpServletRequset请求</td>
<td>pre</td>
</tr>
<tr>
<td>-1</td>
<td>FormBodyWrapperFliter</td>
<td>包装请求体</td>
<td>pre</td>
</tr>
<tr>
<td>1</td>
<td>DebugFilter</td>
<td>包装标记调试标识</td>
<td>pre</td>
</tr>
<tr>
<td>5</td>
<td>PreDecorationFilter</td>
<td>处理请求上下文，供后续处理</td>
<td>pre</td>
</tr>
<tr>
<td>10</td>
<td>RibbonRoutingFilter</td>
<td>serviceid请求转发</td>
<td>route</td>
</tr>
<tr>
<td>100</td>
<td>SimpleHostRoutingFilter</td>
<td>rul请求转发</td>
<td>route</td>
</tr>
<tr>
<td>500</td>
<td>SendForwardFilter</td>
<td>forward请求转发</td>
<td>route</td>
</tr>
<tr>
<td>0</td>
<td>SendErrorFilter</td>
<td>处理error请求响应</td>
<td>post</td>
</tr>
<tr>
<td>1000</td>
<td>SendResponseFilter</td>
<td>处理正常请求响应</td>
<td>post</td>
</tr>
</tbody>
</table>
<h1 id="Zuul异常处理"><a href="#Zuul异常处理" class="headerlink" title="Zuul异常处理"></a>Zuul异常处理</h1><h2 id="error阶段直接抛出异常"><a href="#error阶段直接抛出异常" class="headerlink" title="error阶段直接抛出异常"></a>error阶段直接抛出异常</h2><p>可以看到，核心过滤器并没有实现error阶段，自己实现一个异常过滤器来看看怎么处理<br>1.创建一个pre类型过滤器，在过滤器中抛出一个异常。在api-gateway服务中建立filter包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowExceptionFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ThrowExceptionFilter.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"pre filter,throw RuntimeException"</span>);</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"errors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行注册中心、hello-server、api网关，利用<a href="http://localhost:5555/api-a/hello" target="_blank" rel="noopener">http://localhost:5555/api-a/hello</a> 访问，可以看到报错，api服务控制台输出了错误.</p>
<pre><code>Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Mon Apr 16 15:53:24 CST 2018
There was an unexpected error (type=Internal Server Error, status=500).
pre:ThrowExceptionFilter
</code></pre><p>我们看一下RibbonRoutingFilter下的run如何抛出异常</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">this</span>.helper.addIgnoredHeaders(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RibbonCommandContext commandContext = <span class="keyword">this</span>.buildCommandContext(context);</span><br><span class="line">            ClientHttpResponse response = <span class="keyword">this</span>.forward(commandContext);</span><br><span class="line">            <span class="keyword">this</span>.setResponse(response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>我们相应的改写下</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"即将抛出错误"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>可以看到</p>
<pre><code>Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Mon Apr 16 15:56:20 CST 2018
There was an unexpected error (type=Internal Server Error, status=500).
MY errors!!!!!!
</code></pre><h1 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h1><p>无论是核心过滤器还是自定义的过滤器，只要在Api网关中创建了实例，那么默认情况都是启用状态的。如果不想使用了，该如何禁用过滤器<br>1.可以重写sholdFliter逻辑返回false，但是这样会修改代码重新编译<br>2.特定参数过滤</p>
<pre><code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true
</code></pre><p>其中<simpleclassname>是过滤器名称<filtertype>过滤器类型。如</filtertype></simpleclassname></p>
<pre><code>zuul.AccessFilter.pre.disable=true
</code></pre><p>不仅可以过滤自定义的，核心过滤器也可以过滤。可以将Springcloud的过滤器全部抛弃并实现一套自己的过滤器处理机制。</p>
<hr>
<p>以下部分请先食用Spring Cloud Config后再来看</p>
<h1 id="Zuul动态加载路由及过滤器"><a href="#Zuul动态加载路由及过滤器" class="headerlink" title="Zuul动态加载路由及过滤器"></a>Zuul动态加载路由及过滤器</h1><p><strong>这部分内容需要先看SpringCloudConfig内容</strong><br>API网关可是对外提供服务的入口，7X24小时服务系统，不可能重启及关闭应用，因此必须具备动态更新内部逻辑的能力，比如动态添加删除过滤器、动态修改路由规则</p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>只需要利用config的动态刷新机制，从Git获取配置，轻松实现路由规则的动态刷新，<br>启动eureka，启动配置中心config，config注册到eureka并从Git中获取配置，接下来需要Zuul网关，网关从config获取配置<br>1首先我们在Git上发布我们的配置api-gateway.properties</p>
<pre><code>zuul.routes.service-a.path=/service-a/**
zuul.routes.service-a.serviceId=hello-server
zuul.routes.service-b.path=/service-b/**
zuul.routes.service-b.url=http://www.baidu.com
</code></pre><p>2建立api-gateway-dynamic-route，从config-server中获取配置<br>3pom中引入zuul、eureka、config依赖<br>4bootstrap.properties配置</p>
<pre><code>spring.application.name=api-gateway
server.port=5556
spring.cloud.config.uri=http://localhost:7001/
eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka/
</code></pre><p>5主类添加一个动态刷新RefreshScope</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayDynamicRouteApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayDynamicRouteApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"zuul"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZuulProperties <span class="title">zuulProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZuulProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6启动api-gateway 还有helloserver<br>我们通过访问api-gateway<br><a href="http://localhost:5556/service-a/hello" target="_blank" rel="noopener">http://localhost:5556/service-a/hello</a>   跳转到了hello server的服务<br><a href="http://localhost:5556/service-b" target="_blank" rel="noopener">http://localhost:5556/service-b</a>         跳转到了百度<br>路由实现</p>
<h2 id="动态过滤器"><a href="#动态过滤器" class="headerlink" title="动态过滤器"></a>动态过滤器</h2><p>过滤请求的动态加载也可以通过类似的方式实现,单有所以不同，路由规则是配置，请求过滤是编码实现。<br>所以对于请求过滤去的动态加载，需要借助基于JVM实现的动态语言才行，比如Groovy</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-04 Hystrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-04 Hystrix/" itemprop="url">02、微服务-01、Spring Cloud之04、Hystrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:40Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：集中式传统web开发者，熟悉SpringBoot后可开袋食用！<br>author：ChenGong<br>本文为笔记向！</p>
<h1 id="Hystrix容错保护"><a href="#Hystrix容错保护" class="headerlink" title="Hystrix容错保护"></a>Hystrix容错保护</h1><p>微服务服务拆分多个单元，单元的应用通过注册和订阅的方式相互依赖。远程调用可能会产生故障或延迟，这些问题会直接导致调用方的服务也出现延迟，此时如果调用方请求不断增加，会造成任务积压，最终导致自身服务瘫痪。<br>微服务的这么多单元应用，如果一个单元出现故障，可能会蔓延导致整个系统瘫痪！相较传统架构更不稳定，为了解决这问题，引入断路器等保护机制！</p>
<pre><code>一般情况对于服务依赖的保护主要有3中解决方案：
（1）熔断模式：这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。
（2）隔离模式：这种模式就像对系统请求按类型划分成一个个小岛的一样，当某个小岛被火少光了，不会影响到其他的小岛。例如可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。
（3）限流模式：上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为预防模式。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。
</code></pre><h1 id="Hystrix基本"><a href="#Hystrix基本" class="headerlink" title="Hystrix基本"></a>Hystrix基本</h1><p>Hystrix用了 <strong>命令模式</strong> 及 <strong>RxJava（我们一般写的程序 统称为命令式程序，是以流程为核心的，每一行代码实际上都是机器实际上要执行的指令。而Rxjava这样的编程风格，称为函数响应式编程。函数响应式编程是以数据流为核心，处理数据的输入，处理以及输出的。这种思路写出来的代码就会跟机器实际执行的指令大相径庭）的观察者-订阅者模式</strong></p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式：将客户端的请求封装为一个对象，可使用不同请求对客户端进行参数化。实现行为请求者与行为实现者解耦。<br>简单说，原来是客户端直接调用业务逻辑方法，但是这两个方法有耦合。为了解耦，设计一个中间的命令方法，命令方法接受业务方法bean对象。客户端调用命令方法的excute，命令方法再执行业务代码。<br>例子；<br>解耦后<br>1.操作者：被调用的业务代码</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reciver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//业务代码，等待被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>2.Command接口及实现</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Reciver reciver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Reciver reciver)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reciver=reciver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reciver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>3.调用者Invoker</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommond</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.excute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>4.使用命令模式。可以诸多多个命令模式。比如新建文件、复制文件、删除文件，只需再需要时直接调用即可</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Reciever reciever=<span class="keyword">new</span> Reciever();</span><br><span class="line">        Command command=<span class="keyword">new</span> ConceretCommand(reciever);</span><br><span class="line">        Invoker invoker=<span class="keyword">new</span> Invoker();</span><br><span class="line">        invoker.serCommond(commond);</span><br><span class="line">        invoker.action()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="RxJava观察者-订阅者模式"><a href="#RxJava观察者-订阅者模式" class="headerlink" title="RxJava观察者-订阅者模式"></a>RxJava观察者-订阅者模式</h2><p>a) Observable向订阅者发布事件，Subsciber接受到后进行处理<br>b) Observable可以发出多个事件，直到结束或者发送异常<br>c) Observable每发送一个事件，就要调用Subsciber的onNext()方法<br>d) 每一个Observable执行，最后一定会通过Subsciber的onCompleted或者onError结束操作流</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rx.Observable;</span><br><span class="line"><span class="keyword">import</span> rx.Subscriber;</span><br><span class="line"><span class="comment">//事件源</span></span><br><span class="line">Observable&lt;String&gt; observable=Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello RxJava"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"在不？"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//订阅者</span></span><br><span class="line">Subscriber&lt;String&gt; subscriber=<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Subscriber"</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发布者触发事件发布</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
</code></pre><p>//HotObservable与ColdObservable<br>HotObservable:无论“事件源”是否有“订阅者”，都会在创建事件后发布<br>ColdObservable：不会发布事件，等待有订阅者后发布。</p>
<p>1.创建HystrixCommand或者HystrixObeservableCommand。表示对依赖服务的操作请求。采用 <strong>命令模式</strong> 实现对服务调用的封装。<br>HystrixCommand：依赖的服务返回单个操作结果<br>HystrixObeservableCommand：依赖的服务返回多个操作结果</p>
<p>2.执行命令<br>HystrixCommand执行时会创建Command对象及具体情况选择一个执行</p>
<pre><code>excute():同步，从服务返回单一结果对象，或者错误抛出异常
queue():异步，直接返回Future对象，包含了服务执行结束时要返回的单一结果对象。
</code></pre><p>HystrixObservableCommand执行实现了另外两个执行方式</p>
<pre><code>observe();从服务返回多个结果对象，是一个HotObservable
toObservable();从服务返回多个结果对象，是一个ColdObservable
</code></pre><p>3.结果或是否被缓存<br>4.断路器是否打开<br>5.线程池/请求队列/信号量是否占满<br>6.HystrixCommand.run()<br>7.计算断路器健康度<br>8.fallback处理</p>
<h1 id="Hystrix之断路"><a href="#Hystrix之断路" class="headerlink" title="Hystrix之断路"></a>Hystrix之断路</h1><p>Hystrix实现了断路器、线程隔离等保护功能。<br>当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p>
<p>看个例子。之前我们准备好了注册中心、两个Hello-service服务。我们把他们启动起来<br>消费者进行如下修改<br>1.引入Hystrix</p>
<pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre><p>2.主方法加入@EnableCircuitBreaker,或者@SpringCloudApplication（@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker）<br>3.增加service层</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">HelloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://HELLO-SERVER/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>4.改造controller</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConsumerService consumerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/ribbon-consumer"</span> ,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">HelloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consumerService.HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>准备完毕！<br>启动consumer。我们关掉一台HELLO—SERVER服务器，可以看到轮询结果，访问宕机的server会返回error，而不是错误信息Hystrix服务回掉生效。如果我们重启所有的HELLO—SERVER服务器，它会自动回复</p>
<h1 id="Hystrix之隔离"><a href="#Hystrix之隔离" class="headerlink" title="Hystrix之隔离"></a>Hystrix之隔离</h1><p>通过“舱壁模式”，实现线程池的隔离，为每一个依赖服务创建一个独立的线程池。即使某个依赖服务出现延迟高的情况，也只对依赖服务的调用产生影响，不会拖累其他依赖服务。<br>例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. 这样做的主要优点是运行环境被隔离开了. 这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. 但是带来的代价就是维护多个线程池会对系统带来额外的性能开销. 如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源.</p>
<h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><p>1.创建请求命令<br>单个请求</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(String uid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER_SERVICE/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">getUserById</span><span class="params">(String uid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;User&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER_SERVICE/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>多个请求</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;User&gt; <span class="title">getUserById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;User&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscribee&lt;? <span class="keyword">super</span> User&gt; observer)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!observer.isUnsubscribed())&#123;</span><br><span class="line">                    User user=restTemplate.getForObject(<span class="string">"http://USER_SERVICE/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">                    observer.onNext(user);</span><br><span class="line">                    observer.onComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>（Exception e）&#123;</span><br><span class="line">                observer.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>2.定义服务降级<br>fallback是Hystrix执行命令失败的后被方法。<br>所有的RPC技术里面服务降级是一个最为重要的话题，所谓的降级指的是当服务的提供方不可使用的时候，程序不会出现异常，而会出现本地的操作调</p>
<p>3.请求合并！<br>高并发下远程调用的通信消耗会很大，依赖服务的线程池资源有限，将出现排队等待和和相应延迟。<br>引入请求合并HystrixCollapser可以用来实现请求的合并，以减少通信消耗和线程占用。</p>
<p>HystrixCollapser在HystrixCommand之前放置一个合并处理器，对同一依赖服务的多个请求进行整合并以批量方式发起请求<br>假设微服务提供两个获取User的接口</p>
<pre><code>/users/{id}
/users?ids={ids}
</code></pre><p>消费端调用Service内有两个方法</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">(List&lt;String&gt; ids)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class,StringUtils.join(ids,<span class="string">","</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>我们要来实现将多个单一User对象的请求命令合并。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个用于请求/users/&#123;id&#125;，一个用于请求/users?ids=&#123;ids&#125;</span></span><br><span class="line">    <span class="comment">//在/users/&#123;id&#125;上通过 @HystrixCollapser创建合并请求器，合并窗口时间100毫秒，超过100毫秒无法合并完成则不合并</span></span><br><span class="line">    <span class="meta">@HystrixCollapser</span>(batchMethod=<span class="string">"findAll"</span>,collapserProperties=&#123;</span><br><span class="line">        <span class="meta">@HystrixProperty</span>(name=<span class="string">"timerDelayInMilliseconds"</span>,value=<span class="string">"100"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">(List&lt;String&gt; ids)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,User.class,StringUtils.join(ids,<span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-03 Ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-03 Ribbon/" itemprop="url">02、微服务-01、Spring Cloud之03、Ribbon</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:40Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：集中式传统web开发者，熟悉SpringBoot后可开袋食用！<br>author：ChenGong<br>本文为笔记向！</p>
<h1 id="Ribbon客户端负载"><a href="#Ribbon客户端负载" class="headerlink" title="Ribbon客户端负载"></a>Ribbon客户端负载</h1><p>基于Netflix实现 ，是一个基于Htpp和Tcp的客户端负债均衡工具。可以轻松将面向服务的REST请求自动转换成客户端负债均衡的服务调用。Ribbon有点入侵，几乎存在每个spring cloud构建的微服务中。微服务之剪的调用及API网关的请求转发等，都通过Ribbon实现。<br>负债均衡对于高可用是不得不实施的内容！<br><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-03%20Ribbon/7.jpg" title="负债均衡"><br>负债均衡会通过心跳检测来剔除故障节点。而客户端负债均衡是</p>
<pre><code>将服务清单储存在客户端节点，这些清单来源于注册中心。客户端也会用心跳连接检查服务端情况。在客户端使用负载均衡只需两部
1.服务provider启动多个实例注册到一个注册中心或者有关联的注册中心
2.服务消费者通过调用@LoadBalanced 修饰的RestTemplate调用接口
</code></pre><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><h2 id="a）GET"><a href="#a）GET" class="headerlink" title="a）GET"></a>a）GET</h2><p>get请求可通过两种方式调用。</p>
<p>1）getForEntity：返回对象ResponseEntity（包含比如像HTTP请求状态的枚举对象HttpStatus等）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="comment">//最后一个“菌波儿”参数会替换&#123;1&#125;占位符；getBody()将ResponseEntity种的内容类型返回。</span></span><br><span class="line">ResponseEntity&lt;String&gt; responseStr =</span><br><span class="line">    restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/username/&#123;1&#125;"</span>,String.class,<span class="string">"菌波儿"</span>)</span><br><span class="line">String body=responseStr.getBody();</span><br><span class="line">---</span><br><span class="line"><span class="comment">//如果像返回User对象，也可以如下</span></span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">ResponseEntity&lt;String&gt; responseStr =</span><br><span class="line">    restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/username/&#123;1&#125;"</span>,User.class,<span class="string">"菌波儿"</span>);</span><br><span class="line">User body=responseStr.getBody();</span><br></pre></td></tr></table></figure>
<p>2）getForObject：对getForEntity的进一步封装。通过HttpMessageConvertExtractor对Http的请求响应体body内容进行对象转换，包装成对象。<br>    不再需要getBody();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">String result=restTemplate.getForObject(uri,String.class);</span><br><span class="line">或者</span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">User result=restTemplate.getForObject(uri,User.class);</span><br></pre></td></tr></table></figure>
<h2 id="b）POST"><a href="#b）POST" class="headerlink" title="b）POST"></a>b）POST</h2><p>POST请求可以通过三种调用。<br>1.postForEntity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">和get类似</span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="string">"菌波儿"</span>,<span class="number">24</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity =</span><br><span class="line">    restTemplate.postForEntity(<span class="string">"http://USER-SERVICE/user"</span>,user,String.class);</span><br><span class="line"><span class="comment">//可通过getBody()获取结果</span></span><br></pre></td></tr></table></figure>
<p>2.postForObject同get一样，也是省略getBody（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="string">"菌波儿"</span>,<span class="number">24</span>);</span><br><span class="line">String postResult =</span><br><span class="line">    restTemplate.postForEntity(<span class="string">"http://USER-SERVICE/user"</span>,user,String.class);</span><br></pre></td></tr></table></figure>
<p>2.postForLocation。POST提交请求，返回新的资源URI</p>
<pre><code>USer user=new User（&quot;菌波儿&quot;，24）;
URI responseURI=restTemplate.postForLocation(&quot;http://USER-SERVICE/user&quot;,user);
</code></pre><h2 id="c）PUT"><a href="#c）PUT" class="headerlink" title="c）PUT"></a>c）PUT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">Long id=<span class="number">10000L</span>;</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="string">"菌波儿"</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">//void无返回值</span></span><br><span class="line">restTemplate.put(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,user,id);</span><br></pre></td></tr></table></figure>
<h2 id="d）DELETE"><a href="#d）DELETE" class="headerlink" title="d）DELETE"></a>d）DELETE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">Long id=<span class="number">10000L</span>;</span><br><span class="line">restTemplate.delete(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,id);</span><br></pre></td></tr></table></figure>
<h1 id="Ribbon入侵式实现客户端负债均衡"><a href="#Ribbon入侵式实现客户端负债均衡" class="headerlink" title="Ribbon入侵式实现客户端负债均衡"></a>Ribbon入侵式实现客户端负债均衡</h1><p>通过RibbonLoadBanlancerInterceptor对RestTemplate拦截，利用RibbonLoadBanlancerClient将逻辑服务名为host的URI转为具体实例地址。<br><strong>策略</strong><br>IRule为顶接口，AbstractLoadBanlancerRule抽象类<br>1）RandomRule<br>如名，随机选择服务<br>2）RoundRobinRule<br>线性轮询，看源码，有个count值，轮询10次还找不到服务就会结束<br>3）RetryRule<br>继承RoundRobinRule，添加了一个是时间阈值。选择不到会重试直到时间阈值。<br>4）WeightdResponseTimeRule<br>扩展<em>RoundRobinRule</em></p>
<pre><code>定时任务
WeightdResponseTimeRule策略会通过一个定时任务，为每个服务实例计算权重，30秒一次
权重计算maintainWeight
1.累加每个实例的响应时间
2.为负债均衡维护的实例逐个进行权重计算，计算平均相应时间
实例选择
获取[0,最大权重值）的随机数，遍历权重列表，获取实例
</code></pre><p>。。。还有各种策略，不一一看了，需要根据实际情况查找相关文档！</p>
<h1 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h1><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><p>Ribbon每一个接口都有多种不同的策略实现，依赖关系复杂，直接使用上手困难。Spring CLoud采取了默认的系统配置，引入Ribbon依赖后，可以自动化构建下面的接口实现<br>通过自动化配置的实现按，可以轻松实现客户端负债均衡。可以在SpringBoot下创建对应的实例就可以覆盖默认配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建PingUrl实例，默认NoOpPing不会创建</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRobbinConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPing <span class="title">ribbonPing</span><span class="params">(IClientConfig config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PingUrl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>CAP中，Eureka强调AP原则，同CP原则的Zookeeper不同，Eureka为了保证高可用性，宁愿会接受故障实例，也不要丢掉无故障实例。当服务注册中心故障时，服务实例无法维持心跳链接。CP的会剔除所有服务实例，Eureka会因为丢失85%的实例触发保护机制，保留所有节点，实现微服务之间依然可以相互调用，保证大多数服务正常消费！<br>因此，我们希望在服务调用到故障实例时有点办法。所以，实现服务调用假如一些重试机制。SPringCloud整合Spring Retry增强RestTemplate重试能力</p>
<pre><code>#开启重试机制
spring.cloud.loadbanlancer.retry.enabled=true
#断路器超时时间（需要大于Ribbon超时时间）
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000
#请求连接的超时时间
hello-service.ribbon.ConnectTimeout=250
#请求处理的超时时间。
hello-service.ribbon.ReadTimeout=1000
#对所有操作请求都进行重试。
hello-service.ribbon.OkToRetryOnAllOperations=true
#切换实例的重试次数。
hello-service.ribbon.MaxAutoRetriesNextServer=2
#对当前实例的重试次数。
hello-service.ribbon.MaxAutoRetries=1
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-05 Fegin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-05 Fegin/" itemprop="url">02、微服务-01、Spring Cloud之05、Fegin</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:40Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：集中式传统web开发者，熟悉SpringBoot后可开袋食用！<br>author：ChenGong<br>本文为笔记向！</p>
<h1 id="Feign声明式服务调用"><a href="#Feign声明式服务调用" class="headerlink" title="Feign声明式服务调用"></a>Feign声明式服务调用</h1><h2 id="quick-eg"><a href="#quick-eg" class="headerlink" title="quick eg"></a>quick eg</h2><p>Feign整合了Ribbon和Hystrix，还提供了声明式的web客户端定义方式。</p>
<pre><code>1.pom
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
2.main添加
    @EnableFeignClients
    @EnableDiscoveryClient
3.controller
    @RestController
    public class HelloController {
        @Autowired
        private HelloService helloService;
        @RequestMapping(value = &quot;/fegin-consumer&quot;,method = RequestMethod.GET)
        public String helloConsumer(){
            return helloService.hello();
        }
    }
4.service
    @FeignClient(&quot;hello-service&quot;)
    public interface HelloService {
        @RequestMapping(&quot;/hello&quot;)
        String hello();
    }
5.properties
    spring.application.name=feign-consumer
    server.port=9001
    eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka/
</code></pre><p>可以看到consumer没有通过restTemplate，直接同服务名@FeignClient(“hello-service”)通过<a href="http://localhost:9001/feign-consumer" target="_blank" rel="noopener">http://localhost:9001/feign-consumer</a> ,通过接口的方式访问了hello-service服务提供者，这是一个不带参数的REST服务绑定。</p>
<h2 id="不同的参数绑定方法"><a href="#不同的参数绑定方法" class="headerlink" title="不同的参数绑定方法"></a>不同的参数绑定方法</h2><p>实际业务接口复杂得多，HTTP各个位置需要传入不同类型的参数，返回也可能是一个复杂的对象。首先，我们扩展一下客户端的provider</p>
<pre><code>1.添加User pojo，包含name，age，及空构造！
2.改造controller接口
@RestController
public class HelloController {
    @RequestMapping(value = &quot;/hello&quot;)
    public String hello(){
        return &quot;Hello Eureka&quot;;
    }
    @RequestMapping(value = &quot;/hello1/{name}&quot;,method = RequestMethod.GET)
    public String hello(@PathVariable String name){
        return &quot;Hello Eureka &quot;+name;
    }
    @RequestMapping(value = &quot;/hello2&quot;,method = RequestMethod.GET)
    public User hello(@RequestHeader String name, @RequestHeader Integer age){
        return new User(name,age);
    }
    @RequestMapping(value = &quot;/hello3&quot;,method = RequestMethod.GET)
    public String hello(@RequestBody User user){
        return &quot;hello&quot;+user.getName()+&quot;,&quot;+user.getAge();
    }
}
</code></pre><p>开始对feign consumer绑定请求，首先添加User类。feign采用的类似mvc的语法，但不是完全一样，比如MVC中，注解会根据参数名来作为默认值，但是Feign中绑定的参数必须通过value属性来指明参数名。<br>    1.改造service<br>    @FeignClient(“hello-server”)<br>    public interface HelloService {<br>        @RequestMapping(“/hello”)<br>        String hello();</p>
<pre><code>    @RequestMapping(value = &quot;/hello1/{name}&quot;,method = RequestMethod.GET)
    String hello(@PathVariable(&quot;name&quot;) String name);

    @RequestMapping(value = &quot;/hello2&quot;,method = RequestMethod.GET)
    User hello(@RequestHeader(&quot;name&quot;) String name,@RequestHeader(&quot;age&quot;) Integer age);

    @RequestMapping(value = &quot;/hello3&quot;,method = RequestMethod.POST)
    String hello(@RequestBody User user);
}
2.改造controller
@RestController
public class HelloController {
    @Autowired
    private HelloService helloService;
    @RequestMapping(value = &quot;/fegin-consumer&quot;,method = RequestMethod.GET)
    public String helloConsumer(){
        return helloService.hello();
    }
    @RequestMapping(value = &quot;/fegin-consumer2&quot;,method = RequestMethod.GET)
    public String helloConsumer2(){
        StringBuilder sb=new StringBuilder();
        sb.append(helloService.hello()).append(&quot;\n&quot;);
        sb.append(helloService.hello(&quot;CG&quot;)).append(&quot;\n&quot;);
        sb.append(helloService.hello(&quot;CG&quot;,26)).append(&quot;\n&quot;);
        sb.append(helloService.hello(new User(&quot;lsj&quot;,24))).append(&quot;\n&quot;);
        return sb.toString();
    }
}
</code></pre><p>测试！<br>启动注册中心，启动provider，启动fegin/。</p>
<h2 id="如何在Feign中使用Ribbon"><a href="#如何在Feign中使用Ribbon" class="headerlink" title="如何在Feign中使用Ribbon"></a>如何在Feign中使用Ribbon</h2><p>全局设置</p>
<pre><code>ribbon.ConnectTimeout=500
ribbon.ReadTimeout=5000
</code></pre><h2 id="如何在Feign中使用Hystrix"><a href="#如何在Feign中使用Hystrix" class="headerlink" title="如何在Feign中使用Hystrix"></a>如何在Feign中使用Hystrix</h2><p>默认情况下会将所有方法封装到Hystrix中进行保护</p>
<h2 id="Feign日志配置"><a href="#Feign日志配置" class="headerlink" title="Feign日志配置"></a>Feign日志配置</h2><pre><code>logging.level.com.cg.service.HelloService=DEBUG

@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class FeignApplication {
    @Bean
    Logger.Level feginLoggerLevel(){
        return Logger.Level.FULL;
    }

    public static void main(String[] args) {
        SpringApplication.run(FeignApplication.class, args);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen Gong</p>
              <p class="site-description motion-element" itemprop="description">java 学习 Spring Cloud 微服务 图解源码 陈功</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Gong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
