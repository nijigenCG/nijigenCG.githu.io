<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="java 学习 Spring Cloud 微服务 图解源码 陈功">
<meta property="og:type" content="website">
<meta property="og:title" content="CGの开发万事屋">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="CGの开发万事屋">
<meta property="og:description" content="java 学习 Spring Cloud 微服务 图解源码 陈功">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CGの开发万事屋">
<meta name="twitter:description" content="java 学习 Spring Cloud 微服务 图解源码 陈功">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>CGの开发万事屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CGの开发万事屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">欢迎来到黑铁酒吧，哦不，CG的万事屋(●'◡'●)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-06 Zuul/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-06 Zuul/" itemprop="url">02、微服务-01、Spring Cloud之06、Zuul</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:40Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：集中式传统web开发者，熟悉SpringBoot后可开袋食用！<br>author：ChenGong<br>本文为笔记向！</p>
<h1 id="Zuul网关"><a href="#Zuul网关" class="headerlink" title="Zuul网关"></a>Zuul网关</h1><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-06%20Zuul/8.jpg" title="系统架构">
<p>内部service通过服务注册发现相互调用，还有对外的OpenService，提供对外RESTful API服务，通过Nginx等进行负载均衡后提供给外部客户端。<br>一、但是为了让路由正确分发，实例增减或ip变动等发生的情况，需要手动同步维护，系统规模大是，维护及其不便。<br>二、对外服务会有权限校验等机制，如用户登陆等，为了防止客户端发起请求时被篡改等，还会有签名校验机制。微服务将原本单一的应用拆成了多个应用，我们不得不在每个应用中去实现这样一套逻辑，这些校验代码非常冗余。一旦修改逻辑，需要将所有的应用上的逻辑进行修改。<br>所有我们需要API网关，所有外部客户端访问都需要经过它来进行过滤调度！</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>Zuul通过服务注册中心注册到Eureka，从而获取到服务实例。Zuul会默认通过以服务名作为ContextPath方式来创建映射。<br>对于签名校验，登陆等问题，完全可以做成独立的服务，从应用中剥离，在API网关服务上进行统一的调用来对服务接口做前置过滤。可以通过ZUul创建校验过滤器，指定哪些规则需要执行校验逻辑，通过校验才会被路由到具体的微服务接口，使得微服务更加专注于业务逻辑开发。</p>
<h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><p>我们来新建一个Zuul。<br>spring boot<br>1.pom</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

&lt;groupId&gt;com.cg&lt;/groupId&gt;
&lt;artifactId&gt;api-gateway&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;jar&lt;/packaging&gt;

&lt;name&gt;api-gateway&lt;/name&gt;
&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;spring-cloud.version&gt;Finchley.M9&lt;/spring-cloud.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;
        &lt;version&gt;1.4.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;
        &lt;version&gt;2.0.0.M6&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;

&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-milestones&lt;/id&gt;
        &lt;name&gt;Spring Milestones&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
&lt;/project&gt;
</code></pre><p>2.主类增加@EnableZuulProxy<br>3.配置</p>
<pre><code>spring.application.name=api-gateway
server.port=5555
#服务实例映射
zuul.routes.api-a-url.path=/api-a/**
zuul.routes.api-a.serviceId=HELLO-SERVER
zuul.routes.api-b-url.path=/api-b/**
zuul.routes.api-b.serviceId=FEIGN-CONSUMER
#zuul注册到eureka
eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka
</code></pre><p>然后我们启动eureka注册中心、hello-server provider、feign-consumer、还有api-gateway<br>已经配置了路由规则。我们访问api的<a href="http://localhost:5555/api-b/feign-consumer" target="_blank" rel="noopener">http://localhost:5555/api-b/feign-consumer</a> .api网关吧请求转发到相应的服务实例上去，只需配置简单的path和serviceId映射组合即可。</p>
<h1 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h1><p>实现请求路由的基本功能后，微服务可以通过统一的API网关作为入口进行访问。但是访问权限等没有限制，任何请求都会被转发，最简单粗暴的是在所有微服务上添加一套权限逻辑，但是不可取。我们需要剥离，形成一个独立的鉴权服务。而Zuul的一个核心功能就是：请求过滤，只需要继承ZuulFilter抽象类并实现4个抽象函数即可完成请求的拦截与过滤。耐看一个简单的Zuul过滤器</p>
<pre><code>public class AccessFilter extends ZuulFilter{
    private static Logger log=LoggerFactory.getLogger(AccessFilter.class);
    //过滤器类型，决定过滤器在什么生命周期中执行，pre代表在请求路由之前进行。
    @Override
    public String filterType(){
        return &quot;pre&quot;;
    }
    //过滤器执行顺序
    @Override
    public int filterOrder(){
        return 0;
    }
    //过滤器是否要被执行，可以制定改函数的过滤器有效范围
    @Override
    public boolean shouldFilter(){
        return true;
    }
    //过滤器逻辑类型，context.setSendZuulResponse(false)命令Zuul过滤该请求，
    //context.setResponseStatusCode(401)返回错误代码
    @Override
    public Object run(){
        RequestContext context=RequestContext.getCurrentContext();
        HttpServletRequest requset=context.getRequset();
        log.info(&quot;send {} request to {}&quot;,requset.getMethod(),requset.getRequsetURL().toString());

        Obeject accessToken=requset.getParamter(&quot;accessToken&quot;);
        if(accessToken==null){
            log.warn(&quot;token empty!!&quot;);
            context.setSendZuulResponse(false);
            context.setResponseStatusCode(401);
            return null;
        }
        log.info(&quot;access token ok!&quot;);
        return null;
    }
}
</code></pre><p>实现过滤器后，不会直接生效，需要创建具体的bean才能启动<br>在主类中增加如下方法才会生效</p>
<pre><code>@Bean
public AccessFilter accessFilter（）{
    return new AccessFilter();
}
</code></pre><p>我们测试</p>
<pre><code>http://localhost:5555/api-a/hello
http://localhost:5555/api-a/hello&amp;accessToken=token
</code></pre><h1 id="路由详解"><a href="#路由详解" class="headerlink" title="路由详解"></a>路由详解</h1><h2 id="路由的一些基本配置"><a href="#路由的一些基本配置" class="headerlink" title="路由的一些基本配置"></a>路由的一些基本配置</h2><p>回顾一下路由配置</p>
<pre><code>zuul.routes.api-a-url.path=/api-a/**
zuul.routes.api-a.serviceId=HELLO-SERVER
zuul.routes.api-b-url.path=/api-b/**
zuul.routes.api-b.serviceId=FEIGN-CONSUMER
</code></pre><p>除了path与serviceId的映射外，还有更简洁的配置</p>
<pre><code>#zuul.routes.&lt;serviceId&gt;=&lt;path&gt;
zuul.routes.user-service=/user-service/**
#将zuul看作eureka下的一个服务，他会获取所有实例清单，自己就得到了serviceID与服务实例地址的映射，api网关可自动找到最佳匹配
</code></pre><p>虽然eureka与zuul省去了维护服务配置的工作，但是实际情况一般如下</p>
<pre><code>zuul.routes.fegin-consumer.path=/fegin-consumer/**
zuul.routes.fegin-consumer.serviceId=fegin-consumer
</code></pre><p>zuul的默认规则可以完全不需要我们这样一个一个配置。<br>当我们为API网关引入eureka后，每个服务都会创建一个默认的路由规则，path使用serviceId配置的服务名作为请求前缀。<br>由于默认情况eureka的所有服务都会被zuul自动创建映射，而有些我们不希望暴露出去，可以用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.ignore-serices=*</span><br><span class="line">zuul.routes.hello-server.serviceId=hello-server</span><br></pre></td></tr></table></figure>
<p>如上设置一个服务名匹配表达式来定义不自动映射，只需要添加我们想要暴露的服务hello-server，而fegin-consumer则不会暴露出去</p>
<h2 id="自定义路由规则"><a href="#自定义路由规则" class="headerlink" title="自定义路由规则"></a>自定义路由规则</h2><p>构建微服务时，为了兼容不同外部版本，一般会采用开闭原则进行设计开发。我们可以根据服务版本表示来知道，如下<br>userservice-v1、userservice-v2、orderservice-v1、orderservice-v2<br>这样，路由默认会映射成/userservice-v1、/userservice-v2<br>但是这样不利于通过规则进行管理，可以改成如下这样</p>
<pre><code>/v1/userservice
//PatternServiceRouteMapper添加到主类下，通过正则表达式定义路由映射
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PatternServiceRouteMapper <span class="title">serviceRouteMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PatternServiceRouteMapper(</span><br><span class="line">        <span class="string">"(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)"</span>,</span><br><span class="line">        <span class="string">"$&#123;version&#125;/$&#123;name&#125;"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p>可以通过如下来看</p>
<pre><code>/user-service/?     匹配一个/user-service/a、/user-service/d、/user-service/3
/user-service/*     匹配任意/user-service/afdsfs
/user-service/**    匹配任意及多级目录 /user-service/afdsfs、/user-service/afdsfs/zz
</code></pre><h1 id="Zuul过滤器！"><a href="#Zuul过滤器！" class="headerlink" title="Zuul过滤器！"></a>Zuul过滤器！</h1><p>zuul包含对请求路由及过滤两个功能，路由将外部请求转发到微服务实例，过滤将请求进行校验，实现请求校验服务聚合等功能<br>spring cloud zuul包含4个基本特性实际上ZuulFilter中4个抽象方法：</p>
<h2 id="过滤类型-String-filterType"><a href="#过滤类型-String-filterType" class="headerlink" title="过滤类型 String filterType()"></a>过滤类型 String filterType()</h2><p>需要返回一个字符串代表过滤器类型，Zuul默认了4个不同的生命周期过滤类型。</p>
<pre><code>pre：路由请求前调用
routing：请求时调用
post：routing和error过滤器之后调用
error：处理请求时发生错误被调用
</code></pre><p>filterType4种过滤器类型定义了一个外部HTTP到达API网关，直到返回请求结果的全部生命周期。可以通过下图清晰的看出来流转过程<br><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-06%20Zuul/3.png" title="过滤器流转图"><br>这其中为了让API网关可以更方便使用，默认实现类一批核心的过滤器。定义在springcloud core下的netflix.zuul.filters。<br><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-06%20Zuul/4.png" title="过滤器包下结构"></p>
<h2 id="顺序执行-int-filterOrder"><a href="#顺序执行-int-filterOrder" class="headerlink" title="顺序执行 int filterOrder()"></a>顺序执行 int filterOrder()</h2><pre><code>用值越小优先级越高
</code></pre><h2 id="执行条件-boolean-shouldFilter"><a href="#执行条件-boolean-shouldFilter" class="headerlink" title="执行条件 boolean shouldFilter()"></a>执行条件 boolean shouldFilter()</h2><pre><code>是否执行该过滤器
</code></pre><h2 id="具体操作-Object-run"><a href="#具体操作-Object-run" class="headerlink" title="具体操作 Object run()"></a>具体操作 Object run()</h2><pre><code>自定义过滤逻辑，是否要拦截当前请求
</code></pre><h2 id="过滤器生命周期表"><a href="#过滤器生命周期表" class="headerlink" title="过滤器生命周期表"></a>过滤器生命周期表</h2><table>
<thead>
<tr>
<th>顺序</th>
<th>过滤器</th>
<th>功能</th>
<th>阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td>-3</td>
<td>ServletDetectionFilter</td>
<td>标记处理Servlet的类型</td>
<td>pre</td>
</tr>
<tr>
<td>-2</td>
<td>Servlet30WrapperFilter</td>
<td>包装HttpServletRequset请求</td>
<td>pre</td>
</tr>
<tr>
<td>-1</td>
<td>FormBodyWrapperFliter</td>
<td>包装请求体</td>
<td>pre</td>
</tr>
<tr>
<td>1</td>
<td>DebugFilter</td>
<td>包装标记调试标识</td>
<td>pre</td>
</tr>
<tr>
<td>5</td>
<td>PreDecorationFilter</td>
<td>处理请求上下文，供后续处理</td>
<td>pre</td>
</tr>
<tr>
<td>10</td>
<td>RibbonRoutingFilter</td>
<td>serviceid请求转发</td>
<td>route</td>
</tr>
<tr>
<td>100</td>
<td>SimpleHostRoutingFilter</td>
<td>rul请求转发</td>
<td>route</td>
</tr>
<tr>
<td>500</td>
<td>SendForwardFilter</td>
<td>forward请求转发</td>
<td>route</td>
</tr>
<tr>
<td>0</td>
<td>SendErrorFilter</td>
<td>处理error请求响应</td>
<td>post</td>
</tr>
<tr>
<td>1000</td>
<td>SendResponseFilter</td>
<td>处理正常请求响应</td>
<td>post</td>
</tr>
</tbody>
</table>
<h1 id="Zuul异常处理"><a href="#Zuul异常处理" class="headerlink" title="Zuul异常处理"></a>Zuul异常处理</h1><h2 id="error阶段直接抛出异常"><a href="#error阶段直接抛出异常" class="headerlink" title="error阶段直接抛出异常"></a>error阶段直接抛出异常</h2><p>可以看到，核心过滤器并没有实现error阶段，自己实现一个异常过滤器来看看怎么处理<br>1.创建一个pre类型过滤器，在过滤器中抛出一个异常。在api-gateway服务中建立filter包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowExceptionFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ThrowExceptionFilter.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"pre filter,throw RuntimeException"</span>);</span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"errors"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行注册中心、hello-server、api网关，利用<a href="http://localhost:5555/api-a/hello" target="_blank" rel="noopener">http://localhost:5555/api-a/hello</a> 访问，可以看到报错，api服务控制台输出了错误.</p>
<pre><code>Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Mon Apr 16 15:53:24 CST 2018
There was an unexpected error (type=Internal Server Error, status=500).
pre:ThrowExceptionFilter
</code></pre><p>我们看一下RibbonRoutingFilter下的run如何抛出异常</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">this</span>.helper.addIgnoredHeaders(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RibbonCommandContext commandContext = <span class="keyword">this</span>.buildCommandContext(context);</span><br><span class="line">            ClientHttpResponse response = <span class="keyword">this</span>.forward(commandContext);</span><br><span class="line">            <span class="keyword">this</span>.setResponse(response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZuulException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>我们相应的改写下</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"即将抛出错误"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>可以看到</p>
<pre><code>Whitelabel Error Page
This application has no explicit mapping for /error, so you are seeing this as a fallback.

Mon Apr 16 15:56:20 CST 2018
There was an unexpected error (type=Internal Server Error, status=500).
MY errors!!!!!!
</code></pre><h1 id="禁用过滤器"><a href="#禁用过滤器" class="headerlink" title="禁用过滤器"></a>禁用过滤器</h1><p>无论是核心过滤器还是自定义的过滤器，只要在Api网关中创建了实例，那么默认情况都是启用状态的。如果不想使用了，该如何禁用过滤器<br>1.可以重写sholdFliter逻辑返回false，但是这样会修改代码重新编译<br>2.特定参数过滤</p>
<pre><code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true
</code></pre><p>其中<simpleclassname>是过滤器名称<filtertype>过滤器类型。如</filtertype></simpleclassname></p>
<pre><code>zuul.AccessFilter.pre.disable=true
</code></pre><p>不仅可以过滤自定义的，核心过滤器也可以过滤。可以将Springcloud的过滤器全部抛弃并实现一套自己的过滤器处理机制。</p>
<hr>
<p>以下部分请先食用Spring Cloud Config后再来看</p>
<h1 id="Zuul动态加载路由及过滤器"><a href="#Zuul动态加载路由及过滤器" class="headerlink" title="Zuul动态加载路由及过滤器"></a>Zuul动态加载路由及过滤器</h1><p><strong>这部分内容需要先看SpringCloudConfig内容</strong><br>API网关可是对外提供服务的入口，7X24小时服务系统，不可能重启及关闭应用，因此必须具备动态更新内部逻辑的能力，比如动态添加删除过滤器、动态修改路由规则</p>
<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>只需要利用config的动态刷新机制，从Git获取配置，轻松实现路由规则的动态刷新，<br>启动eureka，启动配置中心config，config注册到eureka并从Git中获取配置，接下来需要Zuul网关，网关从config获取配置<br>1首先我们在Git上发布我们的配置api-gateway.properties</p>
<pre><code>zuul.routes.service-a.path=/service-a/**
zuul.routes.service-a.serviceId=hello-server
zuul.routes.service-b.path=/service-b/**
zuul.routes.service-b.url=http://www.baidu.com
</code></pre><p>2建立api-gateway-dynamic-route，从config-server中获取配置<br>3pom中引入zuul、eureka、config依赖<br>4bootstrap.properties配置</p>
<pre><code>spring.application.name=api-gateway
server.port=5556
spring.cloud.config.uri=http://localhost:7001/
eureka.client.serviceUrl.defaultZone=http://localhost:8765/eureka/
</code></pre><p>5主类添加一个动态刷新RefreshScope</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayDynamicRouteApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayDynamicRouteApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(<span class="string">"zuul"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZuulProperties <span class="title">zuulProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZuulProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6启动api-gateway 还有helloserver<br>我们通过访问api-gateway<br><a href="http://localhost:5556/service-a/hello" target="_blank" rel="noopener">http://localhost:5556/service-a/hello</a>   跳转到了hello server的服务<br><a href="http://localhost:5556/service-b" target="_blank" rel="noopener">http://localhost:5556/service-b</a>         跳转到了百度<br>路由实现</p>
<h2 id="动态过滤器"><a href="#动态过滤器" class="headerlink" title="动态过滤器"></a>动态过滤器</h2><p>过滤请求的动态加载也可以通过类似的方式实现,单有所以不同，路由规则是配置，请求过滤是编码实现。<br>所以对于请求过滤去的动态加载，需要借助基于JVM实现的动态语言才行，比如Groovy</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-03 Ribbon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/06-大后端-05架构-02微服务--01Spring Cloud-03 Ribbon/" itemprop="url">02、微服务-01、Spring Cloud之03、Ribbon</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:38:40Z">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/06-大后端-05-架构/" itemprop="url" rel="index">
                    <span itemprop="name">-06.大后端-05.架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：集中式传统web开发者，熟悉SpringBoot后可开袋食用！<br>author：ChenGong<br>本文为笔记向！</p>
<h1 id="Ribbon客户端负载"><a href="#Ribbon客户端负载" class="headerlink" title="Ribbon客户端负载"></a>Ribbon客户端负载</h1><p>基于Netflix实现 ，是一个基于Htpp和Tcp的客户端负债均衡工具。可以轻松将面向服务的REST请求自动转换成客户端负债均衡的服务调用。Ribbon有点入侵，几乎存在每个spring cloud构建的微服务中。微服务之剪的调用及API网关的请求转发等，都通过Ribbon实现。<br>负债均衡对于高可用是不得不实施的内容！<br><img src="/2018/03/27/06-大后端-05架构-02微服务--01Spring%20Cloud-03%20Ribbon/7.jpg" title="负债均衡"><br>负债均衡会通过心跳检测来剔除故障节点。而客户端负债均衡是</p>
<pre><code>将服务清单储存在客户端节点，这些清单来源于注册中心。客户端也会用心跳连接检查服务端情况。在客户端使用负载均衡只需两部
1.服务provider启动多个实例注册到一个注册中心或者有关联的注册中心
2.服务消费者通过调用@LoadBalanced 修饰的RestTemplate调用接口
</code></pre><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><h2 id="a）GET"><a href="#a）GET" class="headerlink" title="a）GET"></a>a）GET</h2><p>get请求可通过两种方式调用。</p>
<p>1）getForEntity：返回对象ResponseEntity（包含比如像HTTP请求状态的枚举对象HttpStatus等）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="comment">//最后一个“菌波儿”参数会替换&#123;1&#125;占位符；getBody()将ResponseEntity种的内容类型返回。</span></span><br><span class="line">ResponseEntity&lt;String&gt; responseStr =</span><br><span class="line">    restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/username/&#123;1&#125;"</span>,String.class,<span class="string">"菌波儿"</span>)</span><br><span class="line">String body=responseStr.getBody();</span><br><span class="line">---</span><br><span class="line"><span class="comment">//如果像返回User对象，也可以如下</span></span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">ResponseEntity&lt;String&gt; responseStr =</span><br><span class="line">    restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/username/&#123;1&#125;"</span>,User.class,<span class="string">"菌波儿"</span>);</span><br><span class="line">User body=responseStr.getBody();</span><br></pre></td></tr></table></figure>
<p>2）getForObject：对getForEntity的进一步封装。通过HttpMessageConvertExtractor对Http的请求响应体body内容进行对象转换，包装成对象。<br>    不再需要getBody();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">String result=restTemplate.getForObject(uri,String.class);</span><br><span class="line">或者</span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">User result=restTemplate.getForObject(uri,User.class);</span><br></pre></td></tr></table></figure>
<h2 id="b）POST"><a href="#b）POST" class="headerlink" title="b）POST"></a>b）POST</h2><p>POST请求可以通过三种调用。<br>1.postForEntity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">和get类似</span><br><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="string">"菌波儿"</span>,<span class="number">24</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity =</span><br><span class="line">    restTemplate.postForEntity(<span class="string">"http://USER-SERVICE/user"</span>,user,String.class);</span><br><span class="line"><span class="comment">//可通过getBody()获取结果</span></span><br></pre></td></tr></table></figure>
<p>2.postForObject同get一样，也是省略getBody（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="string">"菌波儿"</span>,<span class="number">24</span>);</span><br><span class="line">String postResult =</span><br><span class="line">    restTemplate.postForEntity(<span class="string">"http://USER-SERVICE/user"</span>,user,String.class);</span><br></pre></td></tr></table></figure>
<p>2.postForLocation。POST提交请求，返回新的资源URI</p>
<pre><code>USer user=new User（&quot;菌波儿&quot;，24）;
URI responseURI=restTemplate.postForLocation(&quot;http://USER-SERVICE/user&quot;,user);
</code></pre><h2 id="c）PUT"><a href="#c）PUT" class="headerlink" title="c）PUT"></a>c）PUT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">Long id=<span class="number">10000L</span>;</span><br><span class="line">User user=<span class="keyword">new</span> User(<span class="string">"菌波儿"</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">//void无返回值</span></span><br><span class="line">restTemplate.put(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,user,id);</span><br></pre></td></tr></table></figure>
<h2 id="d）DELETE"><a href="#d）DELETE" class="headerlink" title="d）DELETE"></a>d）DELETE</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate=<span class="keyword">new</span> RestTemplate();</span><br><span class="line">Long id=<span class="number">10000L</span>;</span><br><span class="line">restTemplate.delete(<span class="string">"http://USER-SERVICE/user/&#123;1&#125;"</span>,id);</span><br></pre></td></tr></table></figure>
<h1 id="Ribbon入侵式实现客户端负债均衡"><a href="#Ribbon入侵式实现客户端负债均衡" class="headerlink" title="Ribbon入侵式实现客户端负债均衡"></a>Ribbon入侵式实现客户端负债均衡</h1><p>通过RibbonLoadBanlancerInterceptor对RestTemplate拦截，利用RibbonLoadBanlancerClient将逻辑服务名为host的URI转为具体实例地址。<br><strong>策略</strong><br>IRule为顶接口，AbstractLoadBanlancerRule抽象类<br>1）RandomRule<br>如名，随机选择服务<br>2）RoundRobinRule<br>线性轮询，看源码，有个count值，轮询10次还找不到服务就会结束<br>3）RetryRule<br>继承RoundRobinRule，添加了一个是时间阈值。选择不到会重试直到时间阈值。<br>4）WeightdResponseTimeRule<br>扩展<em>RoundRobinRule</em></p>
<pre><code>定时任务
WeightdResponseTimeRule策略会通过一个定时任务，为每个服务实例计算权重，30秒一次
权重计算maintainWeight
1.累加每个实例的响应时间
2.为负债均衡维护的实例逐个进行权重计算，计算平均相应时间
实例选择
获取[0,最大权重值）的随机数，遍历权重列表，获取实例
</code></pre><p>。。。还有各种策略，不一一看了，需要根据实际情况查找相关文档！</p>
<h1 id="Ribbon配置"><a href="#Ribbon配置" class="headerlink" title="Ribbon配置"></a>Ribbon配置</h1><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><p>Ribbon每一个接口都有多种不同的策略实现，依赖关系复杂，直接使用上手困难。Spring CLoud采取了默认的系统配置，引入Ribbon依赖后，可以自动化构建下面的接口实现<br>通过自动化配置的实现按，可以轻松实现客户端负债均衡。可以在SpringBoot下创建对应的实例就可以覆盖默认配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建PingUrl实例，默认NoOpPing不会创建</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRobbinConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPing <span class="title">ribbonPing</span><span class="params">(IClientConfig config)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PingUrl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>CAP中，Eureka强调AP原则，同CP原则的Zookeeper不同，Eureka为了保证高可用性，宁愿会接受故障实例，也不要丢掉无故障实例。当服务注册中心故障时，服务实例无法维持心跳链接。CP的会剔除所有服务实例，Eureka会因为丢失85%的实例触发保护机制，保留所有节点，实现微服务之间依然可以相互调用，保证大多数服务正常消费！<br>因此，我们希望在服务调用到故障实例时有点办法。所以，实现服务调用假如一些重试机制。SPringCloud整合Spring Retry增强RestTemplate重试能力</p>
<pre><code>#开启重试机制
spring.cloud.loadbanlancer.retry.enabled=true
#断路器超时时间（需要大于Ribbon超时时间）
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000
#请求连接的超时时间
hello-service.ribbon.ConnectTimeout=250
#请求处理的超时时间。
hello-service.ribbon.ReadTimeout=1000
#对所有操作请求都进行重试。
hello-service.ribbon.OkToRetryOnAllOperations=true
#切换实例的重试次数。
hello-service.ribbon.MaxAutoRetriesNextServer=2
#对当前实例的重试次数。
hello-service.ribbon.MaxAutoRetries=1
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/01javaSE-20JDK8特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/01javaSE-20JDK8特性/" itemprop="url">20、JDK8新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T15:58:42Z">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/01-JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">-01.JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>很多blog及文章对jdk的特性讲解<strong>不讲人话</strong>，我决定用人话来写一下java8的新特性，力求简单易懂！</p>
<p>前几天发布了JDK10，现在JDK将极快的速度发布新版本加入新特性。JDK8带来了极大改变，在2014年就已然发布。然而国内还有大量公司使用着JDK7甚至JDK6。。。<br>先回顾一下历代JDK的特性<br>1）JDK5（特性多）</p>
<pre><code>自动装箱拆箱、枚举、静态导入、可变长参数、泛型、foreach循环
</code></pre><p>2）JDK6（特性少）</p>
<pre><code>Desktop类和SystemTray类、轻量级Http Server API
插入式注解处理API、用console开发的控制台程序。
</code></pre><p>3）JDK7（特性较多）</p>
<pre><code>数字变量对下划线的支持（可读性高）、switch支持字符串、
try-cathe-resource自动关闭、捕获多种异常、
创建泛型事类型推断（如List&lt;String&gt; list=new ArrayList&lt;&gt;();ArrayList尖括号不用再写String）
</code></pre><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><p>跳票多年的JDK8带来了大量新特性。</p>
<pre><code>1.速度更快！垃圾回收机制的优化（永久区的取消，新增元空间MetaSpace，直接使用物理内存）
    底层代码优化（如hashMap的红黑树引入），并行的扩展；
2.代码更简洁！ lambda语法的引入
3.强大的Stream API
4.非常便于并行。直接调用相关API就可以！
5.干掉空指针！Optional
</code></pre><p>而国内开发者停留在JDK6~7的时代过长，纯粹的不思考的代码民工过多，JDK8带来了新特性及新编程思维，按照新思维写出来的JDK8代码，会和JDK7的代码有很大的不同。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="Lambda是什么？"><a href="#Lambda是什么？" class="headerlink" title="Lambda是什么？"></a>Lambda是什么？</h3><p>Lambda其实就是一个没有名字的函数，是一串可以像参数一样去参数的代码片段。<br>所以说Lambda可以将函数像传数据一样去传递。<br>这样说不明白吧，来看个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value= <span class="number">1024</span>;</span><br><span class="line">String str=<span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>那么可以把一块代码付给变量吗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockOfCode = <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    System.out.print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java8就可以这样做。但是这样不简洁！<br>1）public是多余的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockOfCode = <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    System.out.print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）doSomething多余，因为已经赋值给blockOfCode了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockOfCode = <span class="keyword">void</span> (String s)&#123;</span><br><span class="line">    System.out.print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）void可以省略，因为java能判断返回类型,参数类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blockOfCode = (s)&#123;</span><br><span class="line">    System.out.print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）大括号可以省，若果是多行还是需要{}的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blockOfCode = (s)</span><br><span class="line">    System.out.print(s);</span><br></pre></td></tr></table></figure>
<p>5）写到一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockOfCode = (s) -&gt; System.out.print(s);</span><br></pre></td></tr></table></figure>
<p>这就是一个lambda表达式！更简洁更灵活！</p>
<p>但是，变量像value，str我们都会为其指定类型，如int String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value= <span class="number">1024</span>;</span><br><span class="line">String str=<span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>而上面的blockOfCode该是什么类型的呢？<br>在java8中，所有lambda的类型都是一个接口，我们管这个接口叫<strong>函数式接口</strong>！Lambda表达式这位那个接口的实现,可以理解成如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyLambda</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;   = (String s) -&gt; System.out.print(s);</span><br></pre></td></tr></table></figure>
<p>但是<strong>函数式接口</strong>只允许有一个接口函数，为了避免后来的人给增加新接口函数，需要加上@FunctionalInterface</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyLambda</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;   = (String s) -&gt; System.out.print(s);</span><br></pre></td></tr></table></figure>
<p>如下所示是一个完整的Lambda表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyLambda</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyLambda blockOfCode = (String s) -&gt; System.out.print(s);</span><br></pre></td></tr></table></figure>
<p>这个例子很容易懂的。</p>
<h3 id="Lambda有啥用？"><a href="#Lambda有啥用？" class="headerlink" title="Lambda有啥用？"></a>Lambda有啥用？</h3><p>异常简洁！<br>基本语法:</p>
<pre><code>(parameters) -&gt; expression
</code></pre><p>或</p>
<pre><code>(parameters) -&gt;{ statements; }
parameters对应接口中抽象的参数列表。expression对应抽象方法的实现功能
</code></pre><p>1）lambda表达式需要函数式接口的支持！！！<br><strong>函数式接口</strong>：接口中只有一个抽象方法！可以用@FunctionalInterface来检测是否为函数式接口<br>先来看简单的例子<br>// 1. 不需要参数,无返回值为 </p>
<pre><code> public void test8(){
    int num=2;//在jdk8中可不写final了，但是本质上还是final的，该值不可改变
    Runnable runnable=new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;run!&quot;+num);
        }
    };
    runnable.run();
    //------------------------------------
    Runnable lambdaRun = () -&gt; System.out.println(&quot;run!&quot;+num);
    lambdaRun.run();
}
</code></pre><p>// 2. 接收一个参数,无返回值<br>    若只有一个参数，括号可以省略<br>    Consumer<integer> consumer= (x) -&gt; System.out.println(x+560);<br>    consumer.accept(23);</integer></p>
<p>// 3. 接受2个参数,执行多条语句</p>
<pre><code>Consumer&lt;Integer&gt; consumer = (x,y) -&gt; {System.out.println(&quot;比较&quot;);return Integer.compare(x,y);};
</code></pre><p>// 4. 接收2个int型整数,返回他们的和</p>
<pre><code>(int x, int y) -&gt; x + y
</code></pre><p>// 5. 参数列表的数据类型可以省略不写。JVM会通过上下文推断数据类型。</p>
<p>例子：<br>1）建立函数式接口</p>
<pre><code>@FunctionalInterface
public interface Myfunction{
    public Integer getValue(Integer num);
}
</code></pre><p>2)使用</p>
<pre><code>public void test(){
    cal(100,(x)-&gt;{x*100+x});
    cal(300 , (x) -&gt; x*x );
}

public Integer cal(Integer num,MyFunction mf){
    return mf.getValue(num)
}
</code></pre><h4 id="A-实现接口"><a href="#A-实现接口" class="headerlink" title="A.实现接口"></a>A.实现接口</h4><pre><code>interface MyLambda{
    void doSomething(String str);
}
</code></pre><p>java 7</p>
<pre><code>public class MyLambdaImpl implements MyLambda{
    @Override
    public void doSomething(String str){
        System.out.print(str);
    }
}
MyLambda myLambda =new MyLambda();
</code></pre><p>java 8</p>
<pre><code>MyLambda myCode = (s) -&gt; System.out.print(s);
</code></pre><h4 id="B-传参数"><a href="#B-传参数" class="headerlink" title="B.传参数"></a>B.传参数</h4><pre><code>interface MyLambda{
    void doSomething(String str);
}

public static void enact(MyLambda mylambda,String s){
    mylambda.doSomething(s);
}
</code></pre><p>java7</p>
<pre><code>public class MyLambdaImpl implements MyLambda{
    @Override
    public void doSomething(String str){
        System.out.print(str);
    }
}
MyLambda MyLambdaImpl=new MyLambdaImpl();
enact(MyLambdaImpl,&quot;hello java7&quot;);
</code></pre><p>java 8</p>
<pre><code>enact((s)-&gt;System.out.print(s),&quot;hello java 8&quot;);
</code></pre><h4 id="C-改写匿名内部类"><a href="#C-改写匿名内部类" class="headerlink" title="C.改写匿名内部类"></a>C.改写匿名内部类</h4><p><strong>首先</strong>，我们先来回顾一个例子。大家都知道Comparator接口,实现Comparator接口会实现compare方法，然后该方法可作为参数进行传递。</p>
<pre><code>public void test(){
    //匿名内部类
    Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return Integer.compare(o1,o2);
        }
    };
    //实际上是传递的一个函数
    TreeSet&lt;Integer&gt; ts=new TreeSet&lt;&gt;(com);
}
</code></pre><p>看看上面这一坨代码吧，可读性也差，那么大一坨匿名内部类，起作用的实际就只有一句</p>
<pre><code>return Integer.compare(o1,o2);
</code></pre><p>来吧，来看看lambda大法</p>
<pre><code>@Test
public void test2(){
    Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(01,02);
    TreeSet&lt;Integer&gt; ts=new TreeSet&lt;&gt;(com);
}
</code></pre><h4 id="D-配合Stream-FunctionalInterface-Lib-forEach-method-reference"><a href="#D-配合Stream-FunctionalInterface-Lib-forEach-method-reference" class="headerlink" title="D.配合Stream,FunctionalInterface Lib, forEach,method reference"></a>D.配合Stream,FunctionalInterface Lib, forEach,method reference</h4><p><strong>然后</strong>，举一个工作中经常遇到的例子；获取当前公司中员工年龄大于35的员工。这种过滤的需求经常会在service中遇到。</p>
<pre><code>//初始化一个List。
List&lt;Emp&gt; emps= Arrays.asList(
        new Emp(&quot;张三1&quot;,18),
        new Emp(&quot;张三2&quot;,54),
        new Emp(&quot;李四&quot;,45),
        new Emp(&quot;王五&quot;,22),
        new Emp(&quot;刘麻子&quot;,36),
        new Emp(&quot;赵四&quot;,28),
);

public List&lt;Emp&gt; filterEmp(List&lt;Emp&gt; emps){
    List&lt;Emp&gt; newemps=new ArrayList&lt;&gt;();
    for(Emp e:emps){
        if(e.getAge()&gt;=35){
            newemps.add(e);
        }
    }
    return newemps;
}
</code></pre><p>传统的过滤方式！写得多，可读性差，看了一大堆才看得到条件<br>同时可变性差，假如我需要再取姓名为“李四”的员工List，又得写一堆foreach遍历！<br>这种处理数据的操作经常发生在Service层的代码里对不对，可读性差且臃肿；<br>顶多可以用<strong>策略模式</strong>或者<strong>匿名内部类</strong>进行优化一下，以下演示传统JDK8之前匿名内部类的处理方式。</p>
<pre><code>//1.用泛型抽象一个返回布尔值的接口
public interface MyPredicate&lt;T&gt; {
    public boolean test(T t);
}
//2.用过滤规则实现
public class FIlterByAge implements MyPredicate&lt;Emp&gt; {
    @Override
    public boolean test(Emp emp) {
        return emp.getAge()&gt;=35;
    }
}
//3.过滤List，通过匿名内部类
@Test
public void test5(){
   List&lt;Emp&gt; empList=filterEmp(emps, new MyPredicate&lt;Emp&gt;() {
       @Override
       public boolean test(Emp emp) {
           return emp.getAge()&gt;=35;
       }
   });
   for(Emp e: empList){
       System.out.println(e.getName());
   }
}
</code></pre><p>通过匿名内部类配合策略模式，我们做到了减少一些无用代码，但是匿名内部类的冗余代码还是存在！<br><strong>现在我们再次祭出lambda大法，showCode</strong></p>
<pre><code>//同上，我们还是需要策略者模式interface MyPredicate&lt;T&gt;和实现类FIlterByAge
//将匿名内部类修改
@Test
public void test6() {
    List&lt;Emp&gt; empList = filterEmp(emps,(e)-&gt;e.getAge()&gt;=35);
    empList.forEach(System.out::println);
}
</code></pre><p>一行代码即完成！</p>
<p><strong>你以为就样就完了？？</strong>不！Lambda结合Stream超乎你的想象，什么策略者模式，还要写接口写实现类，辣鸡；<br>看看Lambda结合Stream怎么处理。</p>
<pre><code>//首先还是要有初始数据
List&lt;Emp&gt; emps= Arrays.asList(
        new Emp(&quot;张三1&quot;,18),
        new Emp(&quot;张三2&quot;,54),
        new Emp(&quot;李四&quot;,45),
        new Emp(&quot;王五&quot;,22),
        new Emp(&quot;刘麻子&quot;,36),
        new Emp(&quot;赵四&quot;,28),
);
//高能！！！
@Test
public void test（）{
    emps.stream()
    .filter((e)-&gt;e.getAge&gt;=35)
    .forEach(System.out::println);
}
//完了
</code></pre><h3 id="Lambda相关例子"><a href="#Lambda相关例子" class="headerlink" title="Lambda相关例子"></a>Lambda相关例子</h3><p>1）调用Collection.sort()方法，定制排序规则，使用lambda作为参数传递</p>
<pre><code> Collections.sort(emps,(e1,e2)-&gt;{
    if(e1.getAge()==e2.getAge()){
        return e1.getName().compareTo(e2.getName());
    }
    else{
        return Integer.compare(e1.getAge(),e2.getAge());
    }
});
</code></pre><p>2) 1声明函数式接口，接口中声明方法public String getValue(String str)<br>   2声明类TestLambda，类中编写方法使用接口作为参数，将一个字符串转为大写，并作为方法返回值<br>   3将一个字符串第2个和第4个索引位置进行截取子字符串。</p>
<pre><code>@FunctionalInterface
public interface MyFunc {
    public String getValue(String str);
}

public class TestLam {
    public String strHand(String str,MyFunc mf){
        return mf.getValue(str);
    }
    @Test
    public void test1(){
        String stringDone=strHand(&quot;\t\t\t   cg在学习   &quot;,(str) -&gt;str.trim());
        System.out.println(stringDone);
        String stringDone1=strHand(&quot;dsadsafsa&quot;,str -&gt; str.toUpperCase());
        System.out.println(stringDone1);
        String stringDone1=strHand(&quot;dsadsafsa&quot;,str -&gt; str.subSting(2,5));
    }
}
</code></pre><p>3) 1声明一个带两泛型的函数式接口，泛型类型&lt;T,R&gt; T为参数值 R为返回值<br>   2接口中声明抽象方法<br>   3TestLam类中声明方法，使用接口作为参数，计算long型参数的和<br>   4计算long型参数的乘积</p>
<pre><code>public interface MyFunc1&lt;T,R&gt; {
    public R getValue(T t1,T t2);
}

public class TestLam {
    public void longCal(Long l1,Long l2,MyFunc1&lt;Long,Long&gt; mf){
        System.out.println(mf.getValue(l1,l2));
    }

    @Test
    public void test3(){
        longCal(100L,307879L,(x,y)-&gt;x+y);
        longCal(100L,307879L,(x,y)-&gt;x*y);
    }
}
</code></pre><p>实际上，函数式接口不需要我们自己建立，java已经提供好了</p>
<h2 id="函数式接口，及java内置函数式接口"><a href="#函数式接口，及java内置函数式接口" class="headerlink" title="函数式接口，及java内置函数式接口"></a>函数式接口，及java内置函数式接口</h2><p>编程思想的不懂将带来代码的巨大不一样<br>命令式编程：how-what 命令机器如何how去做事情，不管你想要的是什么what，他会执行<br>声明式编程：what-how 告诉机器你想要什么what，让机器想出如何去做how</p>
<p>什么是函数式编程？？<br>    函数式编程是种编程方式，它将电脑运算视为函数的计算。<br>    函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。<br>    和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。<br>    和过程化编程相比，函数式编程里函数的计算可随时调用。<br>    行为参数化，一个方法接受多个不同的行为作为参数。<br>    行为参数化可以让代码更好适应不同需求<br>    传递代码，奖新行为作为参数传递给方法。</p>
<pre><code>public static void main(String[] args){
    final long totalPointOfOpenTasks =tasks
        .stream()
        .filter(task -&gt; task.getStatus() == Status.OPEN)
        .mapToInt(Task::getPoints)
        .sum();
}
</code></pre><p>java内置四大函数接口</p>
<pre><code>1）Consumer&lt;T&gt;  消费接口
    void accpet（T t）
2）Supplier&lt;T&gt;  供给接口
    T get();
3）Funcion&lt;T,R&gt; 函数型接口
    R applay(T t);
4）Predicate&lt;T&gt; 断言型接口
    boolean test(T t);
</code></pre><h3 id="Consumer-消费接口"><a href="#Consumer-消费接口" class="headerlink" title="Consumer  消费接口"></a>Consumer<t>  消费接口</t></h3><pre><code>@Test
public void cost(Double money, Consumer&lt;Double&gt; consumer){
    consumer.accept(money);
}
public void buyBook(){
    cost(200.86,(m)-&gt; System.out.println(&quot;花了&quot;+m+&quot;买书&quot;));
}
</code></pre><h3 id="Supplier-供给接口"><a href="#Supplier-供给接口" class="headerlink" title="Supplier  供给接口"></a>Supplier<t>  供给接口</t></h3><pre><code>@Test
public void getRandomNumList(){
    List&lt;Integer&gt; list=getNumList(10,()-&gt;(int)Math.random()*100);
}

public List&lt;Integer&gt; getNumList(Integer num, Supplier&lt;Integer&gt; supplier){
    List&lt;Integer&gt; integerList=new ArrayList&lt;&gt;();
    for (int i=0;i&lt;num;i++){
        integerList.add(supplier.get());
    }
    return integerList;
}
</code></pre><h3 id="Funcion-lt-T-R-gt-函数型接口"><a href="#Funcion-lt-T-R-gt-函数型接口" class="headerlink" title="Funcion&lt;T,R&gt; 函数型接口"></a>Funcion&lt;T,R&gt; 函数型接口</h3><pre><code>@Test
public void test(){
    System.out.println(strHandler(&quot;abcdefghijklmn&quot;,(str)-&gt;str.substring(2,5)));
}
public String strHandler(String str,Function&lt;String,String&gt; func){
    return  func.apply(str);
}
</code></pre><h3 id="Predicate-断言型接口"><a href="#Predicate-断言型接口" class="headerlink" title="Predicate 断言型接口"></a>Predicate<t> 断言型接口</t></h3><pre><code>public List&lt;String&gt; strFilter(List&lt;String&gt; str, Predicate&lt;String&gt; predicate){
    List&lt;String&gt; strList=new ArrayList&lt;&gt;();
    for (String string:strList) {
        if (predicate.test(string)){
            strList.add(string);
        }
    }
    return strList;
}
@Test
public void test4(){
    List&lt;String&gt; strList= Arrays.asList(&quot;dsad&quot;,&quot;dfdsadds&quot;,&quot;2&quot;,&quot;fd&quot;);
    strFilter(strList,(s)-&gt;s.length()&gt;=3);
}
</code></pre><p>##方法应用&amp;构造器引用</p>
<p>###方法应用<br>如果lambda体中的内容有方法已经是实例，我们可以用方法引用<br>三种格式<br>    -对象::实例方法名<br>    -类::静态方法名<br>    -类::实例方法名</p>
<p>1.-对象::实例方法名<br>    public class TestMethodRef{<br>        @Test<br>        public void test1(){<br>            PrintSteam ps=System.out;<br>            Consumer<string> con=(x)-&gt;ps.println(x);<br>            //[—-]接口的返回值类型，参数类型和方法体的保持一致<br>            PrintSteam ps1=System.out;<br>            Consumer<string> con1=ps1::println;</string></string></p>
<pre><code>        Consumer&lt;String&gt; con2=System.out::println;

        con.accept(&quot;dsada&quot;);
        con1.accept(&quot;dsada&quot;);
        con2.accept(&quot;dsada&quot;);
    }
    @Test
    public void test2(){
        Employee emp=new Employee();
        Supplier&lt;String&gt; sup=()-&gt;emp.getName();
        String str=sup.get();

        Supplier&lt;String&gt; sup1=emp::getAge(); 
        String str1=sup1.get();
    }
}
</code></pre><p>2.类::静态方法名</p>
<pre><code>public class TestMethodRef{
    @Test
    public void test(){
        //Integer.compare 静态方法
        Comparator&lt;Integer&gt; com = (x,y)-&gt; Integer.compare(x,y);

        Comparator&lt;Integer&gt; com1 = Integer::compare;
    }
}
</code></pre><p>3.类::实例方法名</p>
<pre><code>public class TestMethodRef{
    @Test
    public void test(){
        BiPredicate&lt;String,String&gt; bp = (x,y)-&gt;x.equals(y);

        BiPredicate&lt;String,String&gt; bp1 = String::equals;
    }
}
</code></pre><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式：</p>
<pre><code>ClassName::new

public class TestMethodRef{
    @Test
    public void test(){
        Supplier&lt;Employee&gt; sup=()-&gt;new Employee();
        sup.get();
        //-------构造器应用,调用的是构造器参数列表和参数列表一致的
        Supplier&lt;Employee&gt; sup2 = Employee::new;
        sup2.get();

        Function&lt;Integer,Employee&gt; fun=(x)-&gt;new Employee(x);

        BiFunction&lt;String,Integer,Employee&gt; fun2=Employee::new;
        Employee emp=fun2.apply(&quot;zhangsan &quot;,23);
    }
}
</code></pre><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><pre><code>public class TestMethodRef{
    @Test
    public void test(){
        Function&lt;Integer,String[]&gt; fun = (x)-&gt;new String[x];
        String[10] str=fun.apply(10);

        Function&lt;Integer,String[]&gt; fun2 = String[]::new;
        String[10] str=fun2.apply(10);

    }
}
</code></pre><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>像写sql一样操作java的数据(数组，集合等)。<br>Stream不会自己储存；<br>Stream不会改变原对象，会返回一个持有结果的新Stream；<br>Stream操作是延迟执行的。</p>
<h3 id="几种获取Stream的方式"><a href="#几种获取Stream的方式" class="headerlink" title="几种获取Stream的方式"></a>几种获取Stream的方式</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.可以通过Collection系列集合提供的Stream()方法或parallelStream()获取流</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">//2.通过Arrays中的静态获取</span></span><br><span class="line">    Employee[] emps = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">    Stream&lt;Employee&gt; stream = Arrays.stream(emps);</span><br><span class="line">    <span class="comment">//3.通过Stream的静态方法of()</span></span><br><span class="line">    Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"aa"</span>,<span class="string">"dsa"</span>,<span class="string">"dsad"</span>);</span><br><span class="line">    <span class="comment">//4.通过无限流创建</span></span><br><span class="line">    Stream&lt;Integer&gt; stream23 = Stream.iterator(<span class="number">0</span>,(x)-&gt;x+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//deal</span></span><br><span class="line">    stream23.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    Stream.generate(()-&gt;Math.random())</span><br><span class="line">                    .limit(<span class="number">5</span>)</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="流水线操作"><a href="#流水线操作" class="headerlink" title="流水线操作"></a>流水线操作</h3><p>包含筛选切片、映射、排序等操作</p>
<ol>
<li><p>筛选切片</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1 filter接受lambda，从流中排除元素</span></span><br><span class="line">    <span class="comment">//2 limit 截断流</span></span><br><span class="line">    Stream&lt;Employee&gt; s = employees.stream()</span><br><span class="line">             .filter(e -&gt; e.getAge()&gt;<span class="number">35</span> )</span><br><span class="line">             .limit(<span class="number">5</span>)<span class="comment">//一但发现5条，.的后续代码不再进行操作</span></span><br><span class="line">             .skip(<span class="number">2</span>) <span class="comment">//跳过前2条</span></span><br><span class="line">             .distinct(); <span class="comment">//必须重写hash equal</span></span><br><span class="line">    <span class="comment">//终止操作</span></span><br><span class="line">    s.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>映射:map接受lambda，将元素转换成其他形式。</p>
<pre><code>flatMap 接受一个函数作为参数，将流中的每个值都换成另一个流
</code></pre> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    list.stream()   </span><br><span class="line">        .map((str) -&gt; str.toUpperCase())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Character&gt; stream = </span><br><span class="line">        list.stream()</span><br><span class="line">            .flatMap(TestStream::filterCharacter)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; list= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character ch : str.toCharArray())&#123;</span><br><span class="line">        list.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="排序、查找匹配、归约收集"><a href="#排序、查找匹配、归约收集" class="headerlink" title="排序、查找匹配、归约收集"></a>排序、查找匹配、归约收集</h3><ol>
<li><p>排序</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    list.stream()   </span><br><span class="line">        .sorted() <span class="comment">//自然排序--comparable</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    employees.stream()   </span><br><span class="line">        .sorted(（e1,e2）-&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(e1.getAge().equals(e2.getAge()))&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.getName().compareTo(e2.getNmae())</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">        <span class="comment">//sorted(Comparator com)自定义排序</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>终止操作</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//allMatch 检查所有是否匹配</span></span><br><span class="line">    <span class="keyword">boolean</span> b1 = employees.stream()</span><br><span class="line">            .allMatch(e -&gt; e.getStatus.equals(Status.BUSY));</span><br><span class="line">    <span class="comment">//anyMatch 至少匹配一个</span></span><br><span class="line">    <span class="keyword">boolean</span> b2 = employees.stream()</span><br><span class="line">            .anyMatch(e -&gt; e.getStatus.equals(Status.BUSY));</span><br><span class="line">    <span class="comment">//noneMatch 同上</span></span><br><span class="line">    <span class="comment">//findFirst</span></span><br><span class="line">    Optional&lt;Employee&gt; op = employees.stream()</span><br><span class="line">            .sorted((e1,e2) -&gt; Double.compare(e1.getSalary(),e2.getSalary())</span><br><span class="line">            .findFirst();</span><br><span class="line">    op.orElse(<span class="keyword">new</span> Employee(<span class="string">"空员工"</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    op.get();</span><br><span class="line">    <span class="comment">//findAny</span></span><br><span class="line">    Optional&lt;Employee&gt; op = employees.stream()</span><br><span class="line">            .filter(e -&gt; e.getStatus().equals(Status.BUSY))</span><br><span class="line">            .findAny();</span><br><span class="line">    op.get();</span><br><span class="line">    <span class="comment">//count</span></span><br><span class="line">    Long count = employees.stream().count();</span><br><span class="line">    <span class="comment">//max,min</span></span><br><span class="line">    Optional&lt;Employee&gt; op = employees.stream()</span><br><span class="line">                            .max((e1,e2) -&gt; Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归约 reduce 收集collect</p>
<p> reduce(T iden,BinaryOperator b) 将流中元素反复结合，得到一个值 T<br> reduce(BinaryOperator b)        将留住元素反复结合得到Optionanl<t></t></p>
<p> collect(Collector c) Collector接口中方法实现了决定如何对流执行收集。Collectors提供了多种静态方法，创建收集器实例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//reduce   假设list为一个数据的list</span></span><br><span class="line">    Integer sum = list.stream()</span><br><span class="line">        <span class="comment">//reduce(起始值，2元运算)</span></span><br><span class="line">        .reduce(<span class="number">0</span>,(x,y) -&gt; x*y );<span class="comment">//起始值作为x，流元素为y</span></span><br><span class="line">    </span><br><span class="line">    Optional&lt;Double&gt; op = employees.stream()</span><br><span class="line">                                    .map(Employee::getSalary)</span><br><span class="line">                                    .reduce(Double::sum);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; names = employees.stream()</span><br><span class="line">             .map(Employee::getName)</span><br><span class="line">             <span class="comment">//按照什么方式进行结果收集</span></span><br><span class="line">             <span class="comment">//Collectors.toSet()  toCollection(HashSet::new)</span></span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">    Long count = employees.stream()</span><br><span class="line">            .collect(Collectors.averagingDouble(Employrr::getSalary));</span><br><span class="line"></span><br><span class="line">    Map&lt;Status,List&lt;Employee&gt;&gt; map = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">    </span><br><span class="line">    Map&lt;Status,Map&lt;String,List&lt;Employee&gt;&gt;&gt; map = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getStatus),Collectors.groupingBy(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(e.getAge()&lt;=<span class="number">35</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"青年"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"非青年"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> map reduce模式</p>
</li>
</ol>
<h3 id="并行流串行流"><a href="#并行流串行流" class="headerlink" title="并行流串行流"></a>并行流串行流</h3><p><strong>Fork/Join</strong> 框架：在必要的情况下，将大任务拆分成小任务，拆到不可分，再将小任务结果进行运行。</p>
<p>采用<strong>工作窃取 work-stealing</strong>模式（当执行新任务时，将其拆分为更小的任务执行，并将小任务加到线程队列中，然后再随机从一个其他线程队列中偷一个并放在自己的队列中执行）</p>
<p>其实在java7中就有该框架，只是实现起来麻烦，不过java8改进了。</p>
<p>如下，java7的实现,如下假设计算一下1-10w的累加。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serId=<span class="number">321321L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">10000</span>;<span class="comment">//拆分次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkCalculate</span><span class="params">(Long start,Long end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start=start;</span><br><span class="line">        <span class="keyword">this</span>.end=end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long compute（）&#123;</span><br><span class="line">        <span class="keyword">long</span> length = end - start；</span><br><span class="line">            <span class="keyword">if</span>(length &lt;= THRESHOLD)&#123;</span><br><span class="line">                <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">long</span> i = start;i&lt;=end;i++)&#123;</span><br><span class="line">                    sum+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">long</span> mid = (start+end) /<span class="number">2</span>;</span><br><span class="line">			   ForkCalculate left = <span class="keyword">new</span> ForkCalculate(start,mid);</span><br><span class="line">                left.fork();</span><br><span class="line">                ForkCalculate right = <span class="keyword">new</span> ForkCalculate(mid+<span class="number">1</span>,end);</span><br><span class="line">                right.fork();</span><br><span class="line">                <span class="keyword">return</span> left.join()+right.join();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main：</span><br><span class="line">	ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">	ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkCalculate(<span class="number">0</span>,<span class="number">100000000L</span>);</span><br><span class="line">	Long sum = pool.invoke(task);</span><br></pre></td></tr></table></figure>
<p>java8的简单实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序流</span></span><br><span class="line">LongStream.rangeClosed(<span class="number">0</span>,<span class="number">10000000L</span>)</span><br><span class="line">    	  .reduce(<span class="number">0</span>,Long::sum);</span><br><span class="line"><span class="comment">//并行流</span></span><br><span class="line">LongStream.rangeClosed(<span class="number">0</span>,<span class="number">10000000L</span>)</span><br><span class="line">    	  .parallel()</span><br><span class="line">    	  .reduce(<span class="number">0</span>,Long::sum);</span><br></pre></td></tr></table></figure>
<h2 id="接口默认方法及静态方法"><a href="#接口默认方法及静态方法" class="headerlink" title="接口默认方法及静态方法"></a>接口默认方法及静态方法</h2><p>接口中现在允许默认方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Myinterface</span></span>&#123;</span><br><span class="line">    <span class="comment">//用default修饰，唯一</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dsad"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>若果一个类继承父类同时实现接口。父类有方法1，接口有默认方法1，则类覆盖接口</li>
<li>如果同时实现两个接口，接口具有相同默认方法，则必须实现。</li>
</ol>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional<t> 是一个容器类，代表一个值存在或者不存在。</t></p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建。of中不能接收null</span></span><br><span class="line">    Optional&lt;Employee&gt; op = Optional.of(<span class="keyword">new</span> Employee());</span><br><span class="line">    <span class="comment">//获取容器中的对象</span></span><br><span class="line">    op.get();</span><br><span class="line">    <span class="comment">//创建空Optional实例</span></span><br><span class="line">    Optional&lt;Employee&gt; op1 = Optional.empty();</span><br><span class="line">    op1.get(); <span class="comment">//空get不到</span></span><br><span class="line">    <span class="comment">//ofNullable(T t)如果t不为null，创建Optional实例，否则创建空实例</span></span><br><span class="line">    Optional&lt;Employee&gt; op2 = Optional.ofNullable(<span class="keyword">new</span> Employee());</span><br><span class="line">    op2.get(); <span class="comment">//可以得到</span></span><br><span class="line">    <span class="comment">//isPresent() 是否包含值</span></span><br><span class="line">    <span class="keyword">if</span>(op.isPresent())&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//orElse(T t) 如果调用对象包含值，则返回该值，否则返回t</span></span><br><span class="line">    <span class="keyword">if</span>(op.orElse(<span class="keyword">new</span> Employee(<span class="string">"zs"</span>,<span class="number">18</span>)))&#123;  <span class="comment">//如果没有值，返回一个构造好的默认</span></span><br><span class="line">     	<span class="comment">//...   </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//orElseGet（Supplier s）函数式接口，类似上面</span></span><br><span class="line">    op.orElseGet( () -&gt; <span class="keyword">new</span> Employee（）)；</span><br><span class="line">    <span class="comment">//map（Function f） 如果有值，处理并返回处理后的Optional。否则返回Optional.empty()</span></span><br><span class="line">    Optional&lt;Employee&gt; op7 = Optional.ofNullable(<span class="keyword">new</span> Employee(<span class="string">"zhangsan"</span>,<span class="number">18</span>));</span><br><span class="line">    Optional&lt;String&gt; sop = op7.map(e -&gt; e.getName());</span><br><span class="line">    <span class="comment">//flatMap（Function mapper）与map类似，但是必须返回Optional</span></span><br><span class="line">    op7.flatMap(e -&gt; Optional.of(e.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日期Api"><a href="#日期Api" class="headerlink" title="日期Api"></a>日期Api</h2><p>全新的日期api，并且不可变，线程安全！</p>
<ol>
<li>java.util.Date月份从0开始，一月是0，十二月是11，变态吧！java.time.LocalDate月份和星期都改成了enum，就不可能再用错了。</li>
<li>java.util.Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</li>
<li>java.util.Date是一个“万能接口”，它包含日期、时间，还有毫秒数，如果你只想用java.util.Date存储日期，或者只存储时间，那么，只有你知道哪些部分的数据是有用的，哪些部分的数据是不能用的。在新的Java 8中，日期和时间被明确划分为LocalDate和LocalTime，LocalDate无法包含时间，LocalTime无法包含日期。当然，LocalDateTime才能同时包含日期和时间。<br>新接口更好用的原因是考虑到了日期时间的操作，经常发生往前推或往后推几天的情况。用java.util.Date配合Calendar要写好多代码，而且一般的开发人员还不一定能写对。</li>
<li>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来<br>SQL -&gt; Java</li>
</ol>
<hr>
<p>date -&gt; LocalDate<br>time -&gt; LocalTime<br>timestamp -&gt; LocalDateTime<br>再也不会出现映射到java.util.Date其中日期或时间某些部分为0的情况了。</p>
<p>以前的多线程操作时间会遇到问题,如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">        Callable&lt;Date&gt; call = <span class="keyword">new</span> Callable&lt;Date&gt;()&#123;</span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Date <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> sdf.parse(<span class="string">"20180805"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ExcutorService pool = Excutors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        List&lt;Future&lt;Date&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            result.add(pool.submit(task));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Future&lt;Date&gt; future : results)&#123;</span><br><span class="line">            sout(future.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LocalDate,LocalTime,LocalDateTime均为不可变对象。</p>
<h3 id="LocalDate-LocalTime-LocalDateTime"><a href="#LocalDate-LocalTime-LocalDateTime" class="headerlink" title="LocalDate\LocalTime\LocalDateTime"></a>LocalDate\LocalTime\LocalDateTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLocalDate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前系统时间。年月日时分秒</span></span><br><span class="line">        LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">        <span class="comment">//获取2019-12-10 14：30：30</span></span><br><span class="line">        LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2019</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">30</span>,<span class="number">30</span>);</span><br><span class="line">        <span class="comment">//ldt.plusYears(2)会产生新实例</span></span><br><span class="line">        LocalDateTime ldt2 = ldt.plusYears(<span class="number">2</span>);</span><br><span class="line">        ldt2.getYear();</span><br><span class="line">        LocalDateTime ldt3 = ldt.minusMonths(<span class="number">2</span>);</span><br><span class="line">        ldt3.getMonth();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>时间戳。以unix元年1970年到现在的毫秒值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstant</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//unix元年时间戳 UTC时区</span></span><br><span class="line">        Instant ins1 = Instant.now();</span><br><span class="line">        <span class="comment">//偏移东八区</span></span><br><span class="line">        OffsetDateTime odt = ins1.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Duration-Period"><a href="#Duration-Period" class="headerlink" title="Duration Period"></a>Duration Period</h3><p>计算 <strong>时间</strong> 间隔Duration、计算 <strong>日期</strong> 间隔Period<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDuration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//unix元年时间戳 UTC时区</span></span><br><span class="line">        Instant ins1 = Instant.now();</span><br><span class="line">        Instant ins2 = Instant.now();</span><br><span class="line">        <span class="comment">//Instant\LocalDate都可以接受</span></span><br><span class="line">        Duration dur = Duration.between(ins1,ins2);</span><br><span class="line">        sout(dur.toMills());</span><br><span class="line">        sout(dur.toHours());</span><br><span class="line">        LocalDate ldt = LocalDate.now();</span><br><span class="line">        LocalDate ldt1 = LocalDate.of(<span class="number">2015</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        Period per = Period.between(ldt,ldt1);</span><br><span class="line">        sout(per.getYears());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><h2 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a>Nashorn</h2><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64."></a>Base64.</h2><h2 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/0-Create-Your-Blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/0-Create-Your-Blog/" itemprop="url">初、使用hexo+github进行blog构建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T16:50:23Z">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/0-玩儿-01-博客构建/" itemprop="url" rel="index">
                    <span itemprop="name">-0.玩儿 -01.博客构建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>食用指南：小白也可食用！<br>author：ChenGong</p>
<p>使用GitHub和hexo博客打造工具可轻松完成博客部署，git上相关blog模板工具众多，总能找到你想要的模板。<br>同时你也可以自己手动打造前端页面。<br>这篇文章将详细将如何打造自己的hexo+github Blog<br>Welcome to <a href="https://nijigencg.github.io/" target="_blank" rel="noopener">CG Blog</a>! </p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>说白了，就是把github当作服务器托管你的页面代码，利用hexo生成代码，<br>并push到git上，通过域名访问就能看到你的Blog</p>
<h3 id="一、github操作"><a href="#一、github操作" class="headerlink" title="一、github操作"></a>一、github操作</h3><p>首先你需要Github。注册你的<a href="https://github.com/" target="_blank" rel="noopener">Github</a>。并为自己取一个帅气的名字！<br>点击Repositories&gt;-New，建立你的Blog存放仓库。<br><img src="/2018/03/23/0-Create-Your-Blog/1.png" title="Blog代码仓库建立"><br>    命名blog仓库，需要保证两个圈的名字是一致的。不一致blog域名会访问不到你的gitblog的！<br><img src="/2018/03/23/0-Create-Your-Blog/2.png" title="Blog仓库命名"><br>    命名完成后，按下图设置你的GitPage。<br><img src="/2018/03/23/0-Create-Your-Blog/3.png" title="GitPage设置"><br>    设置完成后，你就可以点开page链接看到自己主页的原始样子了~</p>
<h3 id="二、node-npm-gitBash安装"><a href="#二、node-npm-gitBash安装" class="headerlink" title="二、node npm gitBash安装"></a>二、node npm gitBash安装</h3><p>接下来，我们需要hexo帮助我们制作页面！<br>我们需要下载两个东西：<br>1.<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git下载</a> 简单说就是用来将你的代码上传下载到git的工具。<br>        直接下载下一步下一步完成安装。<br>2.<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js下载</a> hexo通过npm安装。所以我们需要再Windows上安装npm；<br>        直接下载下一步下一步完成安装。<br>3.使用npm安装Hexo   </p>
<pre><code>npm install -g hexo
a)输入hexo -v，检查hexo是否安装成功
b)建立你的blog文件夹并进入，在此右键，打开GitBashHere
c)hexo init，初始化该文件夹
d)输入hexo g，(生成页面)体验Hexo
e)输入hexo s，开启服务器，访问该网址
f)如果你不想再看，可按Ctrl+C结束该服务。
</code></pre><img src="/2018/03/23/0-Create-Your-Blog/4.jpg" title="HEXO主页">
<h3 id="三、配置hexo书写hello-word！"><a href="#三、配置hexo书写hello-word！" class="headerlink" title="三、配置hexo书写hello word！"></a>三、配置hexo书写hello word！</h3><p>进入你的blog文件夹source&gt;-_posts。文件夹下的md文件就是你写的blog。<br>使用命令创建blog文件</p>
<pre><code>hexo new &quot;myHelloWorld&quot; 
</code></pre><p>md文件可用文本编辑器（推荐微软VS Code）打开。<br>myHelloWorld.md<br>随便敲几行，保存，按照之前的hexo g，hexo s 生成页面，开启服务，看看你的页面。</p>
<p>  更多的hexo及md语法请看相关文档<br><a href="http://wowubuntu.com/markdown/#precode" target="_blank" rel="noopener">1.MarkDown语法</a><br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">2.HEXO</a>! </p>
<h3 id="四、部署到远端"><a href="#四、部署到远端" class="headerlink" title="四、部署到远端"></a>四、部署到远端</h3><p>到目前为止，本地已经配好，如何发布到Git上，并通过互联网访问呢？<br>找到blog文件加的根目录下的_config.yml文件，用文本编辑器打开。<br>在最下面配置（冒号后有个空格！）</p>
<pre><code>deploy:
    type: git
    repository: git@github.com:nijigenCG/nijigenCG.github.io.git
    branch: master
</code></pre><p>将repository里面的nijigenCG还成你的git用户名即可<br>配置完成后，到blog文件夹根目录。输入</p>
<pre><code>hexo generate
hexo deploy
</code></pre><p>配置完成！！<br>通过<a href="https://nijigenCG.github.io即可访问" target="_blank" rel="noopener">https://nijigenCG.github.io即可访问</a></p>
<h3 id="五、高级玩法（待续。。。）"><a href="#五、高级玩法（待续。。。）" class="headerlink" title="五、高级玩法（待续。。。）"></a>五、高级玩法（待续。。。）</h3><p>5.0更换主题<br>5.1添加图片视频等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen Gong</p>
              <p class="site-description motion-element" itemprop="description">java 学习 Spring Cloud 微服务 图解源码 陈功</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Gong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
