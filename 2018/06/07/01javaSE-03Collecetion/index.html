<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="-java源码," />










<meta name="description" content="author：ChenGong Quick Start一、Map接口Map接口下有各种实现类，如HashMap、LinkedHashMap、TreeMap、Hashtable等 1)HashMapHashMap数据结构！比如xx超市用10辆卡车去进货，假如物品全部不分类，一股脑放卡车。等卸货时，日用品部门，食品部门要去拿货上架，问题来了，卡车里的货物杂乱。日用品部门要去找肥皂，需要一个一个卡车去找">
<meta name="keywords" content="-java源码">
<meta property="og:type" content="article">
<meta property="og:title" content="03、Collecetion 源码图解分析">
<meta property="og:url" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/index.html">
<meta property="og:site_name" content="CGの笔记向开发万事屋">
<meta property="og:description" content="author：ChenGong Quick Start一、Map接口Map接口下有各种实现类，如HashMap、LinkedHashMap、TreeMap、Hashtable等 1)HashMapHashMap数据结构！比如xx超市用10辆卡车去进货，假如物品全部不分类，一股脑放卡车。等卸货时，日用品部门，食品部门要去拿货上架，问题来了，卡车里的货物杂乱。日用品部门要去找肥皂，需要一个一个卡车去找">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/1.jpg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/2.jpg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/3.jpeg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/3.jpg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/4.jpg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/5.jpg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/1.png">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/2.png">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/6.jpg">
<meta property="og:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/7.jpg">
<meta property="og:updated_time" content="2018-11-28T02:53:49.739Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="03、Collecetion 源码图解分析">
<meta name="twitter:description" content="author：ChenGong Quick Start一、Map接口Map接口下有各种实现类，如HashMap、LinkedHashMap、TreeMap、Hashtable等 1)HashMapHashMap数据结构！比如xx超市用10辆卡车去进货，假如物品全部不分类，一股脑放卡车。等卸货时，日用品部门，食品部门要去拿货上架，问题来了，卡车里的货物杂乱。日用品部门要去找肥皂，需要一个一个卡车去找">
<meta name="twitter:image" content="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/"/>





  <title>03、Collecetion 源码图解分析 | CGの笔记向开发万事屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CGの笔记向开发万事屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">欢迎来到黑铁酒吧，哦不，CG的万事屋(●'◡'●)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/01javaSE-03Collecetion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chen Gong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CGの笔记向开发万事屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">03、Collecetion 源码图解分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T02:41:53+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/01-JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">-01.JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>author：ChenGong</p>
<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="一、Map接口"><a href="#一、Map接口" class="headerlink" title="一、Map接口"></a>一、Map接口</h2><p>Map接口下有各种实现类，如HashMap、LinkedHashMap、TreeMap、Hashtable等</p>
<h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1)HashMap"></a>1)HashMap</h3><p>HashMap数据结构！比如xx超市用10辆卡<br>车去进货，假如物品全部不分类，一股脑放卡车。等卸货时，日用品部门，食品部门要去拿货上架，问<br>题来了，卡车里的货物杂乱。日用品部门要去找肥皂，需要一个一个卡车去找，那么时间复杂度十分可观。</p>
<p>超市的经理总结了下问题，觉得要按货物大致类别进行分类运送，有专门放衣服的车，有专门放日<br>用品的车，那么找东西花的时间就可以大大缩短了。</p>
<p>HashMap也是用到这种简单的思路，HashMap作为一种数据结构，像数组和链表一样用于常规的增删改查，<br>在存数据的时(put)并不是随便乱放，而是会先做一次类似“分类”（hash算法计算出hashCode）的操作再<br>存储，一旦“分类”存储之后，下次取(get)的时候就可以直接找到根据key值进行哈希算法定位数组下标位<br>置，大大缩短查找的时间。最理想的时间复杂度为O（1）.<br>我们知道数组在执行查、改的效率很高，而增、删(不是尾部)的效率低，链表相反，HashMap则是把这两<br>者结合起来。</p>
<p>要弄清楚HashMap的get过程、put过程、数组扩容问题、多线程死循环、解决高并发等问题，我们需要一<br>些基本的知识准备接下。</p>
<h4 id="a）准备姿势"><a href="#a）准备姿势" class="headerlink" title="a）准备姿势"></a>a）准备姿势</h4><p>1）<strong>HashMap数据结构</strong><br>下面来看HashMap的源码图解<br><img src="/2018/06/07/01javaSE-03Collecetion/1.jpg" title="HashMap结构"><br><img src="/2018/06/07/01javaSE-03Collecetion/2.jpg" title="HashMap内部Node结构"></p>
<p>HashMap 实例化后，会自动初始化一个数组，默认是16个长度的数组。数组中每个“槽位”中存放“黄色方<br>块”(key/value实例)，一个“槽位”可存放很多个“黄色方块”，“黄色方块”之间通过“指针”（next）进行联系，这一连串的“黄色方块”就组成了—-链表。<br>我们再来看单个“黄色方块”的结构，“黄色方块”内部包含key-value（我们存放在map中的键值对），next指<br>向（指向下一个“黄色方块”），hash值（定位数组下标的东西）。<br>好了，以上就是HashMap的基本数据结构啦。</p>
<pre><code>注：JDK7“槽位”中如果有多个“黄色方块”，他们以_单向链表_的形式存在；
    JDK8“槽位”中如果有多个“黄色方块”，假如该“黄色方块”数量多于8个，则会以_红黑树_的数据结构
    进行储存。
为什么会有这样的优化呢。因为假如Hash算法设计得很糟糕，将产生大量的_哈希碰撞_(接下来会讲
hash是什么)，导致一个“槽位”中存放有大量键值对。JDK7处理成单向连表时间复杂度最坏时会变
为o（n），而JDK8采用红黑树的最坏时间复杂度为O(log n).
我们能看到优化的结果，JDK7的HashMap 时间复杂度为o（1）-o（n）;
而JDK8的HashMap 时间复杂度为o（1）-o（log n）;
</code></pre><p>2）<strong>HashCode</strong><br>同样我们来举个例子。楼下快递投放点，有100的架子存放快递，<br><img src="/2018/06/07/01javaSE-03Collecetion/3.jpeg" title="快递架"><br>“白痴快递”的快递小哥来快递不做处理，来一件把一件依次放到架子上，当小区取名去找快递，好了，非洲脸黑的可能从头找到尾才找到自己包裹，于是投诉“白痴快递”，“白痴快递”退出来该小区市场。<br>新来一家“聪明快递”快递小哥根据楼栋号讲100个架子进行分类，来了哪个楼的放哪个架子上，这样小区居民不用挨个找了，极大提高了效率。</p>
<p>这个例子其实就是一个Hash算法的思路，每个小区居民都有自己的hashCode，如4栋李四hashCode就是4栋，5栋王五hashCode就是5栋（hashCode取决于你的hash算法怎么写）。在Java的Object中可以调用hashCode()方法获取对象hashCode，返回一个int值。</p>
<p>那么问题来了，赵六万一也住4栋，赵六的hashCode也是4栋，这就是<em>哈希碰撞</em>。一个不合理的hash算法将产生大量碰撞。</p>
<p>JDK的HashMap内部是一个16位长的数组，假如来了100000个对象让这个map存储，那么不可避免会<em>哈希碰撞</em>，导致每个“槽位”存在大量键值对实例，这时候查找的复杂度将趋向于O(log n),这都是JDK8优化后的结果，对于JDK7的链表模式，将不可想象。<br>16位数组不够用？那就来256位，还不够那就2048位。就是牺牲空间换取时间，我总能保证每个槽位中所含的节点降低。JDK的解决思路就是这样，当然实际更为复杂，c)篇将讲解HashMap是如何扩容，解决单个槽位储存过多Node的问题。</p>
<p>3）<strong>负载因子Capacity&amp;阈值threshold</strong><br>阈值(threshold)<br>负载因子(Capacity)：规定什么时候扩容的一个东西。默认hashmap数组大小为16，存的键值对数量超过16则进行扩容，然而HashMap中并不是等数组满了(达到16)才扩容，它会存在一个阈值(threshold)，只要hashmap里的键值对大于等于这个阈值，那么就要进行扩容。阈值的计算公式：</p>
<pre><code>阈值 = 当前数组长度✖负载因子
threshold = lenght*Capacity
</code></pre><p>JDK默认负载因子为0.75，这应该是开发人员考虑很多因素的结果，当然你也可以自己设置为1.</p>
<pre><code>public HashMap(int initialCapacity, float loadFactor)  
</code></pre><p>扩容就会有rehash，接下来看<br>4）<strong>reHash</strong><br>这里需要多考虑一下，即使扩容了，还是会有多个node存放在一个“槽位”里，同时还有很多“槽位”是空的，这样是不行的，所以我们需要对所有的元素进行再次hash计算，重新分配位置。避免多个方块公用一个槽位。具体原理实现将在c)篇讲解。<br><img src="/2018/06/07/01javaSE-03Collecetion/3.jpg" title="rehash"></p>
<p>好了，以上就是HashMap的准备知识，接下来源码分析</p>
<h4 id="b）HashMap构造源码分析"><a href="#b）HashMap构造源码分析" class="headerlink" title="b）HashMap构造源码分析"></a>b）HashMap构造源码分析</h4><p>1.JDK7<br>    回顾一下，HashMap首先会有自己的数组长度，然后有节点对象，负载因子。还会定义几种构造方法</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap里的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="comment">//Entry对象，存key、value、hash值以及下一个节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认数组大小16(移位运算)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>；</span><br><span class="line"><span class="comment">//负载因子默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; </span><br><span class="line"><span class="comment">//当前存的键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//阀值 = 数组大小 * 负载因子</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认new HashMap数组大小16，负载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以指定数组大小和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略一些逻辑判断</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>2.JDK8 同JDK基本一致，不一致的如下</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转为红黑树的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//JDK8中不再叫Entry，改叫Node，实际上还是继承于Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="b）hash值计算及存-put-取-get-过程源码分析"><a href="#b）hash值计算及存-put-取-get-过程源码分析" class="headerlink" title="b）hash值计算及存(put)取(get)过程源码分析"></a>b）hash值计算及存(put)取(get)过程源码分析</h4><p><strong>1.hash计算</strong><br>假如进行</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br></pre></td></tr></table></figure>
</code></pre><p>jdk会拿到key=”name”，调用native方法对name进行hash计算，native本地方法计算hash值非常快。但是拿到的hash值是一个int类型的数，我们假如hash值为324852，那么这个hash值如何去对应到数组的下标？同时如何尽可能打乱hash值的不同让值更可能地散列？<br>为了解决这两个问题，jdk是如下方式对hash值进行位运算处理的。<br>    <strong>散列化</strong><br>hash值是32位的int类型，所以进行二进制位运算，将高16位与低16位进行异或运算。得到一个新的hash值，尽可能均匀分布（散列原理带学习=====(￣▽￣*)b），减少hash碰撞</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key.hashCode() ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
</code></pre><p>   <strong>对应到数组下标</strong><br>假如数组为16位长度，如何将324852这个越界的下标值对应到16位数组下标去？<br>很简单就是取模嘛。。计算机中采用位运算速度更快</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n-<span class="number">1</span>)&amp;hash   就是  hash % (n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</code></pre><p>这里牵扯到一个问题，加入数组不是2次幂的长度，那么位运算会有问题，假如为15，那么（n-1）&amp;hash 计算14的二进制为 1110 末位为0！之前hash做了那么多工作为了保证更为均匀分布，现在末位为0，0与任何进行与运算都为0！会导致最后一位为1的永远放不了元素。所以数组必须要2次幂的长度，而扩容也需要2倍增长</p>
<p>讲完原理看源码就很简单了</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行hash值位运算，使其能在数组中均匀分布</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将运算好的对应到数组下标</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//计算下标，如果不为空则将Node加入到该下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p><strong>2.put get</strong><br>这部分分两部，JDK7的存取和JDK8的存取，难点在put。而put中的resize将放在下面讲解<br><strong>JDK7的存取过程</strong><br>put的流程如图<br><img src="/2018/06/07/01javaSE-03Collecetion/4.jpg" title="put流程图"></p>
<ul>
<li>先判断key是否为空，如果为空则放到数组指针为0处。</li>
<li>如果key不为空，则调用native方法先计算key的哈希值，拿到哈希值后，做扰动，确保更好的随机性，降低哈希碰撞。</li>
</ul>
<blockquote>
<p>JDK8扰动做一次，做4次的话，多了可能边际效用也不大，为了效率考虑就改成一次。</p>
</blockquote>
<ul>
<li>根据扰动后的哈希值和数组的长度，计算该存到下标的位置,使用 key 的 hash 值对数组长度进行取模</li>
<li>找到下标位置的数组，进行添加操作，如果该位置hash值key值均相同，则替换；否则调用addEntry添加（添加时可能触发resize，c篇讲解）。</li>
</ul>
<p>put都搞清楚了，get就很简单了。</p>
<pre><code>1 根据 key 计算 hash 值。
2 找到相应的数组下标：hash &amp; (length – 1)。
3 遍历该数组位置处的链表，直到找到相等(==或equals)的 key。
</code></pre><p><strong>JDK8的存取过程</strong><br>JDK8的put过程相对于JDk7基本差不多。JDk7是先扩容后插入新值的，JDK8先插值再扩容。相比之前JDK8源码更简洁，但可读性差一点。<br>于是，我们看流程图<br><img src="/2018/06/07/01javaSE-03Collecetion/5.jpg" title="put流程图"></p>
<h4 id="c）扩容resize-分析！难点在于transfer"><a href="#c）扩容resize-分析！难点在于transfer" class="headerlink" title="c）扩容resize()分析！难点在于transfer"></a>c）扩容resize()分析！难点在于transfer</h4><p>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<blockquote>
<p>在阿里巴巴java编程规约也要求初始化hashMap大小。<br>简述一下原理，假设原理数组容量为2^n,扩容后为2^(n+1),上面分析了，元素下标位置和hash最后n位相关。扩容后table索引为后n+1位确定，</p>
</blockquote>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = hash &amp; (<span class="number">2</span>^(n+<span class="number">1</span>)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>元素hash N+1位为0, 移动到原索引位置</li>
<li>元素hash N+1位为1, 移动至原索引两倍位置</li>
</ul>
<p><strong>JDK7 resize transfer</strong> 来看下面图例和源码，相较JDK8简单</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历旧数组中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算在新表中的索引，并到新数组中</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">/*将改位置的数组赋值给链表e的next，然后再把链表e放到数组该下标位置</span></span><br><span class="line"><span class="comment">            也就是将e加到链表头部</span></span><br><span class="line"><span class="comment">            会使得转移前后键值对的顺序颠倒*/</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><img src="/2018/06/07/01javaSE-03Collecetion/1.png" title="第一次循环">
<img src="/2018/06/07/01javaSE-03Collecetion/2.png" title="第二次循环">
<p><strong>JDK8 resize transfer</strong> 相对就复杂多了，把初始化和扩容合在一起了</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *下面主要是数组初始化过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//旧数组的引用</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//旧数组长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//旧数组阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">//新数组长度、新阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//极端情况，旧数组爆满了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//阈值改成最大，放弃治疗直接返回旧数组</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容，这里采用左移运算左移1位，也就是旧数组*2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//同样新阈值也是旧阈值*2</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//初始化在这里</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新阈值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *下面就是resize过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">//创建新数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历旧数组，把原来的引用取消，方便垃圾回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//这个链只有一个节点，根据新数组长度计算在新表中的位置</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//红黑树的处理</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//链表长度大于1，小于8的情况，下面高能，单独拿出来分析</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 进行链表复制</span></span><br><span class="line">                    <span class="comment">// 方法比较特殊： 它并没有重新计算元素在数组中的位置</span></span><br><span class="line">                    <span class="comment">// 而是采用了 原始位置加原数组长度的方法计算得到位置</span></span><br><span class="line">                    <span class="comment">//loHead用于存放下标不需要移动链表的头\loTail 用于存放下标不需要移动链表的next，作用就是一个指针</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//hiHead用于存放下标需要移动链表的头\hiTail 用于存放下标需要移动链表的next，作用就是一个指针</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">/* 注意：不是(e.hash &amp; (oldCap-1));而是(e.hash &amp; oldCap)</span></span><br><span class="line"><span class="comment">                         (e.hash &amp; oldCap) 得到的是 元素的在数组中的位置是否需要移动,示例如下</span></span><br><span class="line"><span class="comment">                         示例1：</span></span><br><span class="line"><span class="comment">                         e.hash=10     0000 1010</span></span><br><span class="line"><span class="comment">                         oldCap=16     0001 0000</span></span><br><span class="line"><span class="comment">                           &amp;   =0      0000 0000       比较高位的第一位 0</span></span><br><span class="line"><span class="comment">                        结论：元素位置在扩容后数组中的位置没有发生改变</span></span><br><span class="line"><span class="comment">                         示例2：</span></span><br><span class="line"><span class="comment">                         e.hash=17     0001 0001</span></span><br><span class="line"><span class="comment">                         oldCap=16     0001 0000</span></span><br><span class="line"><span class="comment">                           &amp;   =1      0001 0000      比较高位的第一位   1</span></span><br><span class="line"><span class="comment">                        结论：元素位置在扩容后数组中的位置发生了改变，新的下标位置是原下标位置+原数组长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                         (e.hash &amp; (oldCap-1)) 得到的是下标位置,示例如下</span></span><br><span class="line"><span class="comment">                         e.hash=10     0000 1010</span></span><br><span class="line"><span class="comment">                         oldCap-1=15   0000 1111</span></span><br><span class="line"><span class="comment">                            &amp;  =10     0000 1010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                         e.hash=17     0001 0001</span></span><br><span class="line"><span class="comment">                         oldCap-1=15   0000 1111</span></span><br><span class="line"><span class="comment">                            &amp;  =1      0000 0001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        新下标位置</span></span><br><span class="line"><span class="comment">                         e.hash=17     0001 0001</span></span><br><span class="line"><span class="comment">                         newCap-1=31   0001 1111    newCap=32</span></span><br><span class="line"><span class="comment">                            &amp;  =17     0001 0001    1+oldCap = 1+16</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</span></span><br><span class="line"><span class="comment">                         0000 0001-&gt;0001 0001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                         因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果原元素位置没有发生变化</span></span><br><span class="line">                            <span class="comment">//分析可知是相当于将链表原原本本移动到新数组位置</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//与上面同理，移动的是下标需要改变的链表</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//这一块就是 旧链表迁移新链表</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;<span class="comment">// 将链表的尾节点 的next 设置为空</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;<span class="comment">// 将链表的尾节点 的next 设置为空</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>总结：<br>1.8中 旧链表迁移新链表 链表元素相对位置没有变化; 实际是对对象的内存地址进行操作，由于是对象内存地址操作，实际上transfer这一步速度也比jdk7快；<br>1.7中  旧链表迁移新链表 如果在新表的数组索引位置相同，则链表元素会倒置（这也是jdk7 hashmap多线程死循环的根源）；</p>
<h4 id="d）线程不安全的HashMap"><a href="#d）线程不安全的HashMap" class="headerlink" title="d）线程不安全的HashMap"></a>d）线程不安全的HashMap</h4><p>hashmap多线程下会造成hashmap死循环（JDK7）、put值无法保证等问题.再有多线程的情况下尽量使用ConcurrentHashMap。<br><strong>JDK7</strong> 情况<br>问题集中再transfer上面</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历旧数组中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算在新表中的索引，并到新数组中</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><blockquote>
<p>下面实例摘自美团技术博客，配上自己的代码注释<br><img src="/2018/06/07/01javaSE-03Collecetion/6.jpg"><br><img src="/2018/06/07/01javaSE-03Collecetion/7.jpg"><br>这个时候形成了循环链表，假如我们get或者put的时候，hash碰撞到了下标为3的位置，就会进入循环链表，链表中没有null，会一直出不去，导致cpu占用100%！</p>
</blockquote>
<p><strong>JDK8</strong> 则修复了该缺陷，前面源码很好的能看出，jdk8全程是没有去修改链表的引用关系</p>
<p>通过源码分析，Java7在多线程操作hashmap时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系；Java8在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。<br>但是不是意味着Java8就可以把HashMap用在多线程中，因为put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，建议使用ConcurrentHashMap。</p>
<h4 id="e）线程安全且高效的ConcurrentHashMap"><a href="#e）线程安全且高效的ConcurrentHashMap" class="headerlink" title="e）线程安全且高效的ConcurrentHashMap"></a>e）线程安全且高效的ConcurrentHashMap</h4><p>Concurrent翻译过来是并发的意思，字面理解它的作用是处理并发情况的 HashMap。多线程并发下 HashMap 是不安全的，常规思路就是给 HashMap 的 put 方法加锁(synchronized)，保证同一个时刻只允许一个线程拥有对 hashmap 有写的操作权限即可。然而假如线程操作耗时，占着茅坑半天不出来，其他需要操作该 hashmap 的线程就需要在门口排队半天，严重影响用户体验( <del>HashTable</del> 就是这么干的)<br>JDK7是采用的分段锁机制，不再讨论过时的，<br>java8改用 CAS + synchronized 控制并发操作；</p>
<h5 id="JDK6与JDK7中的实现"><a href="#JDK6与JDK7中的实现" class="headerlink" title="JDK6与JDK7中的实现"></a>JDK6与JDK7中的实现</h5><p>相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求.<br>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。当用户设置并发度时，<br>ConcurrentHashMap会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）。<br>运行时通过将key的高n位（n = 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。<br>segmentShift与segmentMask都是在构造过程中根据concurrency level被相应的计算出来。</p>
<p>如果并发度设置的过小，会带来严重的锁竞争问题；<br>如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</p>
<h5 id="JDK8的实现"><a href="#JDK8的实现" class="headerlink" title="JDK8的实现"></a>JDK8的实现</h5><p>ConcurrentHashMap在JDK8中进行了巨大改动，弃了Segment（锁段）的概念，启用了CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想(JDK7与JDK8中HashMap的实现)，但是为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。<br><strong>重要的属性</strong><br>首先来看几个重要的属性，与HashMap相同的就不再介绍了，这里重点解释一下sizeCtl这个属性。可以说它是ConcurrentHashMap中出镜率很高的一个属性，因为它是一个控制标识符，在不同的地方有不同用途，而且它的取值不同，也代表不同的含义。</p>
<p>负数代表正在进行初始化或扩容操作<br>-1代表正在初始化<br>-N 表示有N-1个线程正在进行扩容操作<br>正数或0代表hash表还没有被初始化<br>这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</p>
<h3 id="2-HashTable辣鸡，废弃"><a href="#2-HashTable辣鸡，废弃" class="headerlink" title="2)HashTable辣鸡，废弃"></a>2)<del>HashTable辣鸡，废弃</del></h3><p><del>Hashtable</del>是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写<del>Hashtable</del>，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁（JDK8改为了CAS等算法不加锁）。<del>Hashtable</del>不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h3 id="3-LinkedHashMap-待续"><a href="#3-LinkedHashMap-待续" class="headerlink" title="3)LinkedHashMap   (待续)"></a>3)LinkedHashMap   (待续)</h3><h3 id="4-TreeHashMap-待续"><a href="#4-TreeHashMap-待续" class="headerlink" title="4)TreeHashMap   (待续)"></a>4)TreeHashMap   (待续)</h3><h2 id="二、Collection-gt-List-待续"><a href="#二、Collection-gt-List-待续" class="headerlink" title="二、Collection &gt;- List  (待续)"></a>二、Collection &gt;- List  (待续)</h2><p>注意点：遍历增删List<br>1、for循环遍历list</p>
<pre><code>for(int i=0;i&lt;list.size();i++){
    if(list.get(i).equals(&quot;del&quot;))
        list.remove(i);
}
</code></pre><p> 　　这种方式的问题在于，删除某个元素后，list的大小发生了变化，而你的索引也在变化，所以会导致你在遍历的时候漏掉某些元素。比如当你删除第1个元素后，继续根据索引访问第2个元素时，因为删除的关系后面的元素都往前移动了一位，所以实际访问的是第3个元素。因此，这种方式可以用在删除特定的一个元素时使用，但不适合循环删除多个元素时使用。</p>
<p>2、增强for循环</p>
<pre><code>for(String x:list){
    if(x.equals(&quot;del&quot;))
        list.remove(x);
}
</code></pre><p> 　　这种方式的问题在于，删除元素后继续循环会报错误信息ConcurrentModificationException，因为元素在使用的时候发生了并发的修改，导致异常抛出。但是删除完毕马上使用break跳出，则不会触发报错。</p>
<p>3、iterator遍历</p>
<pre><code>Iterator&lt;String&gt; it = list.iterator();
while(it.hasNext()){
    String x = it.next();
    if(x.equals(&quot;del&quot;)){
        it.remove();
    }
}
</code></pre><p>　　这种方式可以正常的循环及删除。但要注意的是，使用iterator的remove方法</p>
<h2 id="三、Collection-gt-Set-待续"><a href="#三、Collection-gt-Set-待续" class="headerlink" title="三、Collection &gt;- Set  (待续)"></a>三、Collection &gt;- Set  (待续)</h2><h2 id="四、Collection-gt-Queue-待续"><a href="#四、Collection-gt-Queue-待续" class="headerlink" title="四、Collection &gt;- Queue  (待续)"></a>四、Collection &gt;- Queue  (待续)</h2><h2 id="五、待续"><a href="#五、待续" class="headerlink" title="五、待续"></a>五、待续</h2>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="Chen Gong 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java源码/" rel="tag"># -java源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/05/05-后端框架-01-Spring-02-Bean装配/" rel="next" title="05-后端框架-01 Spring -02 IOC Bean装配">
                <i class="fa fa-chevron-left"></i> 05-后端框架-01 Spring -02 IOC Bean装配
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/07/05-后端框架-01-Spring-03-高级装配/" rel="prev" title="05-后端框架-01 Spring -03 IOC 高级装配">
                05-后端框架-01 Spring -03 IOC 高级装配 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chen Gong</p>
              <p class="site-description motion-element" itemprop="description">java 学习 Spring Cloud 微服务 图解源码 陈功</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Quick-Start"><span class="nav-number">1.</span> <span class="nav-text">Quick Start</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、Map接口"><span class="nav-number">1.1.</span> <span class="nav-text">一、Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HashMap"><span class="nav-number">1.1.1.</span> <span class="nav-text">1)HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a）准备姿势"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">a）准备姿势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b）HashMap构造源码分析"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">b）HashMap构造源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b）hash值计算及存-put-取-get-过程源码分析"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">b）hash值计算及存(put)取(get)过程源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c）扩容resize-分析！难点在于transfer"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">c）扩容resize()分析！难点在于transfer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d）线程不安全的HashMap"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">d）线程不安全的HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e）线程安全且高效的ConcurrentHashMap"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">e）线程安全且高效的ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK6与JDK7中的实现"><span class="nav-number">1.1.1.6.1.</span> <span class="nav-text">JDK6与JDK7中的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK8的实现"><span class="nav-number">1.1.1.6.2.</span> <span class="nav-text">JDK8的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-HashTable辣鸡，废弃"><span class="nav-number">1.1.2.</span> <span class="nav-text">2)HashTable辣鸡，废弃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-LinkedHashMap-待续"><span class="nav-number">1.1.3.</span> <span class="nav-text">3)LinkedHashMap   (待续)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-TreeHashMap-待续"><span class="nav-number">1.1.4.</span> <span class="nav-text">4)TreeHashMap   (待续)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Collection-gt-List-待续"><span class="nav-number">1.2.</span> <span class="nav-text">二、Collection &gt;- List  (待续)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Collection-gt-Set-待续"><span class="nav-number">1.3.</span> <span class="nav-text">三、Collection &gt;- Set  (待续)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Collection-gt-Queue-待续"><span class="nav-number">1.4.</span> <span class="nav-text">四、Collection &gt;- Queue  (待续)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、待续"><span class="nav-number">1.5.</span> <span class="nav-text">五、待续</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen Gong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
